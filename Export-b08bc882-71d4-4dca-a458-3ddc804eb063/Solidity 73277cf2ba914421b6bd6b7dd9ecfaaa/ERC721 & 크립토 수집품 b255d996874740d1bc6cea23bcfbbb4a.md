# ERC721 & 크립토 수집품

### 이더리움 상의 토큰

- **토큰** : 기본적으로 그저 몇몇 공통 규약을 따르는 스마트 컨트랙트. 즉, 다른 모든 토ㄱ큰 컨트랙트가 사용하는 표준 함수 집합을 구현한것
    - 예를 들면 `transfer(address _to, uint256 _value)`나 `balanceOf(address _owner)`같은 함수들이 있음.
    - 내부적으로 스마트 컨트랙트는 보통 `mapping(address => uint256) balances`와 같은 매핑을 가지고 있음. 각각의 주소에 잔액이 얼마나 있는지 기록.
    - 본적으로 토큰은 그저 하나의 컨트랙트. 그 안에서 누가 얼마나 많은 토큰을 가지고 있는지 기록하고, 몇몇 함수를 가지고 사용자들이 그들의 토큰을 다른 주소로 전송할 수 있게 해주는 것.
- 이렇게 하는 이유
    - 모든 ERC20 토큰들이 똑같은 이름의 동일한 함수 집합을 공유하기 때문에, 이 토큰들에 똑같은 방식으로 상호작용이 가능
    - 즉 자네가 하나의 ERC20 토큰과 상호작용할 수 있는 애플리케이션 하나를 만들면, 이 앱이 다른 어떤 ERC20 토큰과도 상호작용이 가능
        - 방식으로 커스텀 코드를 추가하지 않고 앱에 더 많은 토큰들을 추가할 수 있음
        - 그저 새로운 토큰의 컨트랙트 주소만 끼워넣으면 됨
    - 예로는 거래소가 있음
        - 한 거래소에서 새로운 ERC20 토큰을 상장할 때, 실제로는 이 거래소에서 통신이 가능한 또 하나의 스마트 컨트랙트를 추가하는 것
        - 사용자들은 이 컨트랙트에 거래소의 지갑 주소에 토큰을 보내라고 할 수 있음
        - 거래소에서는 이 컨트랙트에 사용자들이 출금을 신청하면 토큰을 다시 돌려보내라고 할 수 있게 만드는 것.
    - 거래소에서는 이 전송 로직을 한 번만 구현하면 됨. 그리고 새로운 ERC20토큰을 추가 하고 싶으면, 데이터베이스에 단순히 새 컨트랙트 주소를 추가만 하면됨
- 다른 토크 표준
    - ERC20 토큰은 화폐처럼 사용되는 토큰으로는 정말 적절. 그러나 좀비 게임은 부적절
        - 첫째로, 좀비는 화폐처럼 분할할 수가 없음 - 0.237ETH를 보낼 수 있지만, 0.237개의 좀비를 보내는 것은 말이 되지 않음.
        - 둘째로, 모든 좀비가 똑같지는 않음. 자네의 레벨2 좀비 "**Steve**"는 내 레벨732 좀비 "**H4XF13LD MORRIS**"와는 완전히 다름.
    - **ERC721 토큰**
        - ***ERC721 토큰***은 교체가 **불가** (각각의 토큰이 유일하고 분할이 불가)
        - 이 토큰을 하나의 전체 단위로만 거래할 수 있고, 각각의 토큰은 유일한 ID를 가지고 있음
        
        > *ERC721과 같은 표준을 사용하면 우리의 컨트랙트에서 사용자들이 우리의 좀비를 거래/판매할 수 있도록 하는 경매나 중계 로직을 우리가 직접 구현하지 않아도 된다는 이점이 있네. 우리가 스펙에 맞추기만 하면, 누군가 ERC721 자산을 거래할 수 있도록 하는 거래소 플랫폼을 만들면 우리의 ERC721 좀비들을 그 플랫폼에서 쓸 수 있게 될 것이네. 그러니 자네만의 거래 로직을 만드느라 고생하는 것보다 토큰 표준을 사용하는 것이 명확한 이점이 있는 것이지.*
        > 
- 예제) 다음 챕터에서 ERC721을 구현하기 시작할 것. 그전에 먼저, 이번 레슨을 위한 파일 구조 생성. 모든 ERC721 로직을 `ZombieOwnership`이라는 컨트랙트에 저장
    1. 파일의 최상단에 `pragma` 버전을 선언하게(문법은 이전 레슨의 파일에서 참고하게).
    2. 이 파일은 `zombieattack.sol`을 `import` 해야 하네.
    3. `ZombieOwnership`이라는 새로운 컨트랙트를 선언하고, `ZombieAttack`을 상속하게. 컨트랙트의 내용은 지금 당장은 비워두게.
    - 예제 코드
        
        ```solidity
        // 여기서 시작
        pragma solidity ^0.4.19;
        
        import "./zombieattack.sol";
        
        contract ZombieOwnership is ZombieAttack {
            
        }
        ```
        

### ERC721 표준, 다중 상속

- ERC표준
    - 구현해야할 메소드 목록
    
    ```solidity
    contract ERC721 {
      event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
      event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);
    
      function balanceOf(address _owner) public view returns (uint256 _balance);
      function ownerOf(uint256 _tokenId) public view returns (address _owner);
      function transfer(address _to, uint256 _tokenId) public;
      function approve(address _to, uint256 _tokenId) public;
      function takeOwnership(uint256 _tokenId) public;
    }
    ```
    
    > *참고: **ERC721** 표준은 현재 초안인 상태이고, 아직 공식으로 채택된 구현 버전은 없네. 이 튜토리얼에서 우리는 **OpenZeppelin** 라이브러리에서 쓰이는 현재 버전을 사용할 것이지만, 공식 릴리즈 이전에 언젠가 바뀔 가능성도 있네. 그러니 하나의 구현 가능한 버전 정도로만 생각하고, ERC721 토큰의 정식 표준으로 생각하지는 말게.*
    > 
- 토큰 컨트랙트 구현
    - 토큰 컨트랙트를 구현할 때, 처음 해야할 일ㅇ느 인터페이스를 솔리디티 파일로 따로 복사하여 저장하고 `import "./erc721.sol";`을 써서 임포트를 해야함.
    - 해당 컨트랙트를 상속하는 우리의 컨트랙트를 만들고, 각각의 함수를 오버라이딩하여 정의
- 다중 상속
    - 다수의 컨트랙트를 상속할 수 있음
        
        ```solidity
        contract SatoshiNakamoto is NickSzabo, HalFinney {
        }
        ```
        
        - 다중 상속을 쓸 때는 상속하고자 하는 다수의 컨트랙트를 쉼표(`,`)로 구분하면 됨.
- 예제)
    1. `erc721.sol` 파일을 `zombieownership.sol` 파일에서 임포트하게.
    2. `ZombieOwnership`이 `ZombieAttack`과 `ERC721`을 상속한다고 선언하게.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombieattack.sol";
        // 여기서 import 하게.
        import "./erc721.sol";
        
        // 여기서 ERC721 상속을 선언하게.
        contract ZombieOwnership is ZombieAttack, ERC721 {
        
        }
        ```
        

### ****balanceOf & ownerOf****

- **balanceOf**
    
    ```solidity
    function balanceOf(address _owner) public view returns (uint256 _balance);
    ```
    
    - 단순히 `address`를 받아, 해당 `address`가 토큰을 얼마나 가지고 있는지 반환
- **ownerOf**
    
    ```solidity
    function ownerOf(uint256 _tokenId) public view returns (address _owner);
    ```
    
    - 토큰 ID(우리의 경우에는 좀비 ID)를 받아, 이를 소유하고 있는 사람의 `address`를 반환
    - 이 정보를 저장하는 `mapping`을 우리 DApp에 이미 가지고 있기 때문에 이 함수들은 단 한 줄로 구현할 수 있음. `return`문장 하나로 가능.
- 예제)각각의 함수는 `return`을 쓰는 딱 1줄의 코드로만 구성. 이전 레슨들에서 코드를 살펴보고 우리가 이 데이터들을 어디에 저장하는지 확인.
    1. `_owner`가 가진 좀비의 수를 반환하도록 `balanceOf`를 구현하게.
    2. ID가 `_tokenId`인 좀비를 가진 주소를 반환하도록 `ownerOf`를 구현하게. 
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombieattack.sol";
        import "./erc721.sol";
        
        contract ZombieOwnership is ZombieAttack, ERC721 {
        
          function balanceOf(address _owner) public view returns (uint256 _balance) {
            // 1. 여기서 `_owner`가 가진 좀비의 수를 반환하게.
            return ownerZombieCount[_owner];
          }
        
          function ownerOf(uint256 _tokenId) public view returns (address _owner) {
            // 2. 여기서 `_tokenId`의 소유자를 반환하게.
            return zombieToOwner[_tokenId];
          }
        
          function transfer(address _to, uint256 _tokenId) public {
        
          }
        
          function approve(address _to, uint256 _tokenId) public {
        
          }
        
          function takeOwnership(uint256 _tokenId) public {
        
          }
        }
        ```
        

### 리팩토링

- `zombiefeeding.sol`에서 `ownerOf`와 똑같은 이름의 `modifier`를 만들어서 컴파일 오류
    - `ZombieOwnership`의 함수 이름을 다른 걸로 바꿀수는 없음
        - ERC721 토큰 표준을 사용. 즉 다른 컨트랙트들이 우리의 컨트랙트가 정확한 이름으로 정의된 함수들을 가지고 있을 것이라 예상한다는 것
        - 만약 우리 컨트랙트는 ERC721을 따른다는 것을 다른 컨트랙트가 안다면, 이 다른 컨트랙트는 우리의 내부 구현 로직을 모르더라도 우리와 통신할 수 있음
    - `modifier`의 이름을 다른 것으로 바꾸도록 리팩토링
- 예제) `zombiefeeding.sol`로 돌아와서, `modifier`의 이름을 `ownerOf`에서 `onlyOwnerOf`로 바꿀 것
    1. 제어자를 정의하는 이름을 `onlyOwnerOf`로 바꾸게.
    2. 이 제어자를 사용하는 `feedAndMultiply` 함수로 스크롤을 내리게. 여기서도 그 이름을 바꿔야 할 것이네.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefactory.sol";
        
        contract KittyInterface {
          function getKitty(uint256 _id) external view returns (
            bool isGestating,
            bool isReady,
            uint256 cooldownIndex,
            uint256 nextActionAt,
            uint256 siringWithId,
            uint256 birthTime,
            uint256 matronId,
            uint256 sireId,
            uint256 generation,
            uint256 genes
          );
        }
        
        contract ZombieFeeding is ZombieFactory {
        
          KittyInterface kittyContract;
        
          // 1. 제어자의 이름을 `onlyOwnerOf`로 바꾸게.
          modifier onlyOwnerOf(uint _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            _;
          }
        
          function setKittyContractAddress(address _address) external onlyOwner {
            kittyContract = KittyInterface(_address);
          }
        
          function _triggerCooldown(Zombie storage _zombie) internal {
            _zombie.readyTime = uint32(now + cooldownTime);
          }
        
          function _isReady(Zombie storage _zombie) internal view returns (bool) {
              return (_zombie.readyTime <= now);
          }
        
          // 2. 여기서도 제어자의 이름을 바꾸게.
          function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal onlyOwnerOf(_zombieId) {
            Zombie storage myZombie = zombies[_zombieId];
            require(_isReady(myZombie));
            _targetDna = _targetDna % dnaModulus;
            uint newDna = (myZombie.dna + _targetDna) / 2;
            if (keccak256(_species) == keccak256("kitty")) {
              newDna = newDna - newDna % 100 + 99;
            }
            _createZombie("NoName", newDna);
            _triggerCooldown(myZombie);
          }
        
          function feedOnKitty(uint _zombieId, uint _kittyId) public {
            uint kittyDna;
            (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
            feedAndMultiply(_zombieId, kittyDna, "kitty");
          }
        }
        ```
        

### ERC721: 전송로직

- 우리의 ERC721에서 한 사람이 다른 사람에게 소유권을 넘기는 것을 구현
- ERC721 스펙에서는 토큰을 전송할 때 2개의 다른 방식
    
    ```solidity
    function transfer(address _to, uint256 _tokenId) public;
    function approve(address _to, uint256 _tokenId) public;
    function takeOwnership(uint256 _tokenId) public;
    ```
    
    1. 첫 번째 방법은 토큰의 소유자가 전송 상대의 `address`, 전송하고자 하는 `_tokenId`와 함께 `transfer` 함수를 호출하는 것이네.
    2. 두 번째 방법은 토큰의 소유자가 먼저 위에서 본 정보들을 가지고 `approve`를 호출하는 것이네. 그리고서 컨트랙트에 누가 해당 토큰을 가질 수 있도록 허가를 받았는지 저장하지. 보통 `mapping (uint256 => address)`를 써서 말이지. 이후 누군가 `takeOwnership`을 호출하면, 해당 컨트랙트는 이 `msg.sender`가 소유자로부터 토큰을 받을 수 있게 허가를 받았는지 확인하네. 그리고 허가를 받았다면 해당 토큰을 그에게 전송하지.
    - `transfer`와 `takeOwnership` 모두 동일한 전송 로직을 가지고 있음. 순서만 반대인 것(전자는 토큰을 보내는 사람이 함수를 호출; 후자는 토큰을 받는 사람이 호출하는 것).
    - 이 로직만의 프라이빗 함수, `_transfer`를 만들어 추상화하는 것이 좋을 것. 두 함수에서 모두 쓸 수 있음.
- 예제) `_transfer`에 대한 로직을 정의.
    1. `_transfer`라는 이름으로 함수를 정의하게. `address _from`, `address _to`, 그리고 `uint256 _tokenId` 세 개의 인수를 받고, `private` 함수이어야 하네.
    2. 소유자가 바뀌면 함께 바뀔 2개의 매핑을 쓸 것이네: `ownerZombieCount`(한 소유자가 얼마나 많은 좀비를 가지고 있는지 기록)와 `zombieToOwner`(어떤 좀비를 누가 가지고 있는지 기록)이네.
        
        이 함수에서 처음 해야 할 일은 바로 좀비를 **받는** 사람(`address _to`)의 `ownerZombieCount`를 증가시키는 것이네. 증가시킬 때 `++`를 사용하도록 하게.
        
    3. 다음으로, 좀비를 **보내는** 사람(`address _from`)의 `ownerZombieCount`를 감소시켜야 하네. 감소시킬 때 `-`를 쓰도록 하게.
    4. 이 `_tokenId`에 해당하는 `zombieToOwner` 매핑 값이 `_to`를 가리키도록 변경.
    5. ERC721 스펙에는 `Transfer` 이벤트가 포함되어 있네. 이 함수의 마지막 줄에서 적절한 정보와 함께 `Transfer`를 실행해야 하네 - `erc721.sol`을 보고 어떤 인수들이 필요한지 확인한 후 여기에 그걸 구현.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombieattack.sol";
        import "./erc721.sol";
        
        contract ZombieOwnership is ZombieAttack, ERC721 {
        
          function balanceOf(address _owner) public view returns (uint256 _balance) {
            return ownerZombieCount[_owner];
          }
        
          function ownerOf(uint256 _tokenId) public view returns (address _owner) {
            return zombieToOwner[_tokenId];
          }
        
          // 여기에 _transfer()를 정의하게.
          function _transfer(address _from, address _to, uint256 _tokenId) private {
              ownerZombieCount[_to]++;
              ownerZombieCount[_from]--;
              zombieToOwner[_tokenId] = _to;
              Transfer(_from, _to, _tokenId);
          }
        
          function transfer(address _to, uint256 _tokenId) public {
        
          }
        
          function approve(address _to, uint256 _tokenId) public {
        
          }
        
          function takeOwnership(uint256 _tokenId) public {
        
          }
        }
        ```
        
- 예제2 ) 퍼블릭 `transfer`함수를 구현
    1. 우리는 토큰/좀비의 소유자만 해당 토큰/좀비를 전송할 수 있도록 하고 싶네. 자네, 어떻게 그 소유자만 이 함수에 접근할 수 있도록 제한하는지 기억하고 있나?
        
        그래, 바로 그거지. 우리는 이미 이렇게 만들어주는 제어자를 가지고 있네. 그러니 이 함수에 `onlyOwnerOf` 제어자를 추가하게.
        
    2. 이제 함수의 내용은 진짜로 딱 한 줄이면 되네... 그저 `_transfer`를 호출하기만 하면 되지. `address _from` 인수에 `msg.sender`를 전달하는 것을 잊지 말게. 
    - 예제2 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombieattack.sol";
        import "./erc721.sol";
        
        contract ZombieOwnership is ZombieAttack, ERC721 {
        
          function balanceOf(address _owner) public view returns (uint256 _balance) {
            return ownerZombieCount[_owner];
          }
        
          function ownerOf(uint256 _tokenId) public view returns (address _owner) {
            return zombieToOwner[_tokenId];
          }
        
          function _transfer(address _from, address _to, uint256 _tokenId) private {
            ownerZombieCount[_to]++;
            ownerZombieCount[_from]--;
            zombieToOwner[_tokenId] = _to;
            Transfer(_from, _to, _tokenId);
          }
        
          // 1. 여기에 제어자를 추가하게.
          function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
            // 2. 여기서 함수를 정의하게.
            _transfer(msg.sender, _to, _tokenId);
          }
        
          function approve(address _to, uint256 _tokenId) public {
        
          }
        
          function takeOwnership(uint256 _tokenId) public {
        
          }
        }
        ```
        

### ERC721: Approve

- approve
    - `approve`/ `takeOwnership`을 사용하는 전송은 2단계로 나뉨
        1. 소유자인 자네가 새로운 소유자의 `address`와 그에게 보내고 싶은 `_tokenId`를 사용하여 `approve`를 호출.
        2. 새로운 소유자가 `_tokenId`를 사용하여 `takeOwnership` 함수를 호출하면, 컨트랙트는 그가 승인된 자인지 확인하고 그에게 토큰을 전송.
    - 이처럼 2번의 함수 호출이 발생하기 때문에, 함수 호출 사이에 누가 무엇에 대해 승인이 되었는지 저장할 데이터 구조가 필요할 것
- 예제)
    1. 먼저, `zombieApprovals` 매핑을 정의해보도록 하지. 이것은 `uint`를 `address`로 연결하여야 하네.
        
        이런 방식으로, 누군가 `_tokenId`로 `takeOwnership`을 호출하면, 이 매핑을 써서 누가 그 토큰을 가지도록 승인받았는지 확인할 수 있네.
        
    2. `approve` 함수에서, 우리는 오직 그 토큰의 소유자만 다른 사람에게 토큰을 줄 수 있는 승인을 할 수 있도록 하고 싶네. 그러니 `approve`에 `onlyOwnerOf` 제어자를 추가해야 할 것이네.
    3. 함수의 내용에서는 `zombieApprovals`의 `_tokenId` 요소를 `_to` 주소와 같도록 만들게.
    4. 마지막으로, ERC721 스펙에 `Approval` 이벤트가 있네. 그러니 우리는 이 함수의 마지막에서 이 이벤트를 호출해야 하네. `erc721.sol`에서 인수를 확인하고, `msg.sender`를 `_owner`에 쓰도록 하게. 
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombieattack.sol";
        import "./erc721.sol";
        
        contract ZombieOwnership is ZombieAttack, ERC721 {
        
          // 1. 여기에 mapping을 정의하게.
          mapping (uint => address) zombieApprovals;
        
          function balanceOf(address _owner) public view returns (uint256 _balance) {
            return ownerZombieCount[_owner];
          }
        
          function ownerOf(uint256 _tokenId) public view returns (address _owner) {
            return zombieToOwner[_tokenId];
          }
        
          function _transfer(address _from, address _to, uint256 _tokenId) private {
            ownerZombieCount[_to]++;
            ownerZombieCount[_from]--;
            zombieToOwner[_tokenId] = _to;
            Transfer(_from, _to, _tokenId);
          }
        
          function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
            _transfer(msg.sender, _to, _tokenId);
          }
        
          // 2. 여기에 함수 제어자를 추가하게.
          function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
            // 3. 여기서 함수를 정의하게.
            zombieApprovals[_tokenId] = _to;
            Approval(msg.sender, _to, _tokenId);
          }
        
          function takeOwnership(uint256 _tokenId) public {
        
          }
        }
        ```
        

### ****ERC721: takeOwnership****

- 마지막 함수인 `takeOwnership`에서는 `msg.sender`가 이 토큰/좀비를 가질 수 있도록 승인되었는지 확인하고, 승인이 되었다면 `_transfer`를 호출
- 예제)
    1. 먼저, `require` 문장을 써서 `zombieApprovals`의 `_tokenId` 요소가 `msg.sender`와 같은지 확인해야 하네.
        
        이런 방식으로 만약 `msg.sender`가 이 토큰을 받도록 승인되지 않았다면, 에러를 만들어낼 것이네.
        
    2. `_transfer`를 호출하기 위해, 우리는 그 토큰을 소유한 사람의 주소를 알 필요가 있네(함수에서 `_from`을 인수로 요구하기 떄문이지). 다행히 우리의 `ownerOf` 함수를 써서 이를 찾아낼 수 있네.
        
        그러니 `address` 변수를 `owner`라는 이름으로 선언하고, 여기에 `ownerOf(_tokenId)`를 대입하게.
        
    3. 마지막으로, `_transfer`를 필요한 모든 정보와 함께 호출하게(여기서는 `msg.sender`를 `_to`에 사용하면 되네. 이 함수를 호출하는 사람이 토큰을 받을 사람이기 떄문이지).
    
    > 참고: 2번째와 3번째 단계를 한 줄의 코드로 만들 수 있지만, 나누는 것이 조금 더 읽기 좋게 만듬. 개인적인 선호.
    > 
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombieattack.sol";
        import "./erc721.sol";
        
        contract ZombieOwnership is ZombieAttack, ERC721 {
        
          mapping (uint => address) zombieApprovals;
        
          function balanceOf(address _owner) public view returns (uint256 _balance) {
            return ownerZombieCount[_owner];
          }
        
          function ownerOf(uint256 _tokenId) public view returns (address _owner) {
            return zombieToOwner[_tokenId];
          }
        
          function _transfer(address _from, address _to, uint256 _tokenId) private {
            ownerZombieCount[_to]++;
            ownerZombieCount[_from]--;
            zombieToOwner[_tokenId] = _to;
            Transfer(_from, _to, _tokenId);
          }
        
          function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
            _transfer(msg.sender, _to, _tokenId);
          }
        
          function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
            zombieApprovals[_tokenId] = _to;
            Approval(msg.sender, _to, _tokenId);
          }
        
          function takeOwnership(uint256 _tokenId) public {
            // 여기서 시작하게.
            require(zombieApprovals[_tokenId] == msg.sender);
            address owner = ownerOf(_tokenId);
            _transfer(owner, msg.sender, _tokenId);
          }
        }
        ```
        

### 오버플로우

- 컨트랙트 보안 강화 : 오버플로우와 언더플로우
    - 오버플로우: 변수에 타입 보다 큰 값을 넣는것
    - 언더플로우 : `0`값을 가진 `uint8`에서 `1`을 빼면, `255`와 같아지는 것

### SafeMath 사용하기

- 오버플로우나, 언더플로우를 막기 위해 `SafeMath` 라는 라이브러리 사용
- ***라이브러리(Library)***는 솔리디티에서 특별한 종류의 컨트랙트
    - 유용하게 사용되는 경우 중 하나는 기본(native) 데이터 타입에 함수를 붙일 때
    - afeMath 라이브러리를 쓸 때는 `using SafeMath for uint256`이라는 구문을 사용
    - SafeMath 라이브러리는 4개의 함수 : `add`, `sub`, `mul`,  `div`
- 예제)컨트랙트가 SafeMath 라이브러리를 쓰도록 만든다.
    1. `safemath.sol`을 `zombiefactory.sol`에 임포트.
    2. `using SafeMath for uint256;` 선언을 추가.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./ownable.sol";
        // 1. 여기서 import 하게.
        import "./safemath.sol";
        
        contract ZombieFactory is Ownable {
        
          // 2. 여기에 using safemath를 선언하게.
          using SafeMath for uint256;
        
          event NewZombie(uint zombieId, string name, uint dna);
        
          uint dnaDigits = 16;
          uint dnaModulus = 10 ** dnaDigits;
          uint cooldownTime = 1 days;
        
          struct Zombie {
            string name;
            uint dna;
            uint32 level;
            uint32 readyTime;
            uint16 winCount;
            uint16 lossCount;
          }
        
          Zombie[] public zombies;
        
          mapping (uint => address) public zombieToOwner;
          mapping (address => uint) ownerZombieCount;
        
          function _createZombie(string _name, uint _dna) internal {
            uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;
            zombieToOwner[id] = msg.sender;
            ownerZombieCount[msg.sender]++;
            NewZombie(id, _name, _dna);
          }
        
          function _generateRandomDna(string _str) private view returns (uint) {
            uint rand = uint(keccak256(_str));
            return rand % dnaModulus;
          }
        
          function createRandomZombie(string _name) public {
            require(ownerZombieCount[msg.sender] == 0);
            uint randDna = _generateRandomDna(_name);
            randDna = randDna - randDna % 100;
            _createZombie(_name, randDna);
          }
        
        }
        ```
        

### SafeMath 내부코드

```solidity
library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
```

- `library`키워드 :
    - `contract`와 비슷하지만 다른 점, 라이브러리는 우리가 `using`키워드를 사용할 수 있게 해줌.
    - 이를 통해 라이브러리의 메소드들을 다른 데이터 타입에 적용.

```solidity
using SafeMath for uint;
// 우리는 이제 이 메소드들을 아무 uint에서나 쓸 수 있네.
uint test = 2;
test = test.mul(3); // test는 이제 6이 되네
test = test.add(5); // test는 이제 11이 되네
```

- `mul`과 `add`함수는 각각 2개의 인수를 필요. 하지만 인수 1개만 넘김
    - `using SafeMath for uint`를 선언할 때, 함수를 적용하는 `uint`(`test`)는 첫 번째 인수로 자동으로 전달
- `add`함수
    
    ```solidity
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
      uint256 c = a + b;
      assert(c >= a);
      return c;
    }
    ```
    
    - `**assert` 구문을 써서 그 합이 `a`보다 크도록 보장하지. 이것이 오버플로우를 막아줌**
- **assert**
    - `assert`와 `require` 의 공통점 :
        - 조건을 만족하지 않으면 에러를 발생시킨다는 점에서 비슷
    - `assert`와 `require`의 차이점 :
        - `require`는 함수 실행이 실패하면 남은 **가스**를 사용자에게 되돌려 줌
        - `assert`는 그렇지 않다는 것
    - `assert`는 일반적으로 코드가 **심각하게** 잘못 실행될 때 사용
        - ex)`uint`오버플로우
- 예제) 오버플로우나 언더플로우를 막기 위해, 코드에서 `+`, `-`, `*` 또는 `/`을 쓰는 곳을 찾아 `add`, `sub`, `mul`, `div`로 교체
    1. `++`를 SafeMath 메소드로 교체하게.
    2. `-`를 SafeMath 메소드로 교체하게. 
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombieattack.sol";
        import "./erc721.sol";
        import "./safemath.sol";
        
        contract ZombieOwnership is ZombieAttack, ERC721 {
        
          using SafeMath for uint256;
        
          mapping (uint => address) zombieApprovals;
        
          function balanceOf(address _owner) public view returns (uint256 _balance) {
            return ownerZombieCount[_owner];
          }
        
          function ownerOf(uint256 _tokenId) public view returns (address _owner) {
            return zombieToOwner[_tokenId];
          }
        
          function _transfer(address _from, address _to, uint256 _tokenId) private {
            // 1. SafeMath의 `add`로 교체하게.
            ownerZombieCount[_to] = ownerZombieCount[_to].add(1);
            // 2. SafeMath의 `sub`로 교체하게.
            ownerZombieCount[_from] = ownerZombieCount[_from].sub(1);
            zombieToOwner[_tokenId] = _to;
            Transfer(_from, _to, _tokenId);
          }
        
          function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
            _transfer(msg.sender, _to, _tokenId);
          }
        
          function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
            zombieApprovals[_tokenId] = _to;
            Approval(msg.sender, _to, _tokenId);
          }
        
          function takeOwnership(uint256 _tokenId) public {
            require(zombieApprovals[_tokenId] == msg.sender);
            address owner = ownerOf(_tokenId);
            _transfer(owner, msg.sender, _tokenId);
          }
        }
        ```
        

### ****SafeMath (변수타입이 다른 경우)****

- `uint16`, `uint32` 타입의 인수를 써서 **SefeMath**의 `add` 메소드를 사용하면, 이 타입들을 `uint256` 으로 바꾸기 때문에 오버플로우를 막아주지 못함
- `uint16`과 `uint32`에서 오버플로우/언더플로우를 막기 위해 2개의 라이브러리를 더 만들어야 한다는 것을 의미
- `using SafeMath for uint256;` : `uint256`변수타입에 `SafeMath` 라이브러리 사용
- `using SafeMath32 for uint32;` : `uint32`변수타입에 `SafeMath32` 라이브러리 사용
- `using SafeMath16 for uint16;` : `uint16`변수타입에 `SafeMath16` 라이브러리 사용
- 예제)
    1. 우리가 `SafeMath32`를 `uint32`에 쓴다는 것을 선언하게.
    2. 우리가 `SafeMath16`을 `uint16`에 쓴다는 것을 선언하게.
    3. ZombieFactory에 SafeMath 메소드를 사용해야 할 곳이 한 줄 더 있네. 어딘지 가리키는 주석을 남겨놓았네. 
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./ownable.sol";
        import "./safemath.sol";
        
        contract ZombieFactory is Ownable {
        
          using SafeMath for uint256;
          // 1. using SafeMath32 for uint32를 선언하게.
          using SafeMath32 for uint32;
          // 2. using SafeMath16 for uint16를 선언하게.
          using SafeMath16 for uint16;
        
          event NewZombie(uint zombieId, string name, uint dna);
        
          uint dnaDigits = 16;
          uint dnaModulus = 10 ** dnaDigits;
          uint cooldownTime = 1 days;
        
          struct Zombie {
            string name;
            uint dna;
            uint32 level;
            uint32 readyTime;
            uint16 winCount;
            uint16 lossCount;
          }
        
          Zombie[] public zombies;
        
          mapping (uint => address) public zombieToOwner;
          mapping (address => uint) ownerZombieCount;
        
          function _createZombie(string _name, uint _dna) internal {
            // 참고: 우리는 Year 2038 문제를 막지 않기로 하겠네... 그러니 readyTime에서 오버플로우를 걱정할 필요는 없네.
            // 우리 앱은 2038년에는 좀 꼬이겠지 ;)
            uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;
            zombieToOwner[id] = msg.sender;
            // 3. 여기에 SafeMath의 `add`를 사용하게:
            ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].add(1);
            NewZombie(id, _name, _dna);
          }
        
          function _generateRandomDna(string _str) private view returns (uint) {
            uint rand = uint(keccak256(_str));
            return rand % dnaModulus;
          }
        
          function createRandomZombie(string _name) public {
            require(ownerZombieCount[msg.sender] == 0);
            uint randDna = _generateRandomDna(_name);
            randDna = randDna - randDna % 100;
            _createZombie(_name, randDna);
          }
        
        }
        ```
        
- 예제2)
    - `ZombieAttack`에서 `++` 증가 부분을 SafeMath 메소드로 구성
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiehelper.sol";
        
        contract ZombieAttack is ZombieHelper {
          uint randNonce = 0;
          uint attackVictoryProbability = 70;
        
          function randMod(uint _modulus) internal returns(uint) {
            // 여기 하나 있네!
            randNonce = randNonce.add(1);
            return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
          }
        
          function attack(uint _zombieId, uint _targetId) external onlyOwnerOf(_zombieId) {
            Zombie storage myZombie = zombies[_zombieId];
            Zombie storage enemyZombie = zombies[_targetId];
            uint rand = randMod(100);
            if (rand <= attackVictoryProbability) {
              // 여기 세 개 더 있군!
              myZombie.winCount = myZombie.winCount.add(1);
              myZombie.level = myZombie.level.add(1);
              enemyZombie.lossCount = enemyZombie.lossCount.add(1);
              feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");
            } else {
              // ...그리고 2개 더!
              myZombie.lossCount = myZombie.lossCount.add(1);
              enemyZombie.winCount = enemyZombie.winCount.add(1);
              _triggerCooldown(myZombie);
            }
          }
        }
        ```
        

### 주석

- ****주석을 위한 문법****
    - `//` : 한줄 주석
    - `/* */` : 여러 줄 주석
- 솔리디티 커뮤니티에서 표준으로 쓰이는 형식은 ***natspec***
    
    ```solidity
    /// @title 기본적인 산수를 위한 컨트랙트
    /// @author H4XF13LD MORRIS 💯💯😎💯💯
    /// @notice 지금은 곱하기 함수만 추가한다.
    contract Math {
      /// @notice 2개의 숫자를 곱한다.
      /// @param x 첫 번쨰 uint.
      /// @param y 두 번째 uint.
      /// @return z (x * y) 곱의 값
      /// @dev 이 함수는 현재 오버플로우를 확인하지 않는다.
      function multiply(uint x, uint y) returns (uint z) {
        // 이것은 일반적인 주석으로, natspec에 포함되지 않는다.
        z = x * y;
      }
    }
    ```
    
    - `@notice`는 **사용자**에게 컨트랙트/함수가 무엇을 하는지 설명
    - `@dev`는 개발자에게 추가적인 상세 정보를 설명하기 위해 사용
    - `@param`과 `@return`은 함수에서 어떤 매개 변수와 반환값을 가지는지 설명
- 예제) `ZombieOwnership`에 natspec 태그를 추가
    1. `@title` - 예를 들어, 좀비 소유권 전송을 관리하는 컨트랙트라고 쓰게.
    2. `@author` - 자네의 이름!
    3. `@dev` - 예를 들어, OpenZeppelin의 ERC721 표준 초안 구현을 따른다고 하게.
    - 예제 코드)
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombieattack.sol";
        import "./erc721.sol";
        import "./safemath.sol";
        
        /// TODO: natspec에 맞도록 이 부분을 바꾸게.
        //@title 좀비 소유권 전송을 관리하는 컨트랙트
        //@author myang><
        //@dev OpenZeppelin의 ERC721 표준 초안 구현을 따른다
        contract ZombieOwnership is ZombieAttack, ERC721 {
        
          using SafeMath for uint256;
        
          mapping (uint => address) zombieApprovals;
        
          function balanceOf(address _owner) public view returns (uint256 _balance) {
            return ownerZombieCount[_owner];
          }
        
          function ownerOf(uint256 _tokenId) public view returns (address _owner) {
            return zombieToOwner[_tokenId];
          }
        
          function _transfer(address _from, address _to, uint256 _tokenId) private {
            ownerZombieCount[_to] = ownerZombieCount[_to].add(1);
            ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].sub(1);
            zombieToOwner[_tokenId] = _to;
            Transfer(_from, _to, _tokenId);
          }
        
          function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
            _transfer(msg.sender, _to, _tokenId);
          }
        
          function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
            zombieApprovals[_tokenId] = _to;
            Approval(msg.sender, _to, _tokenId);
          }
        
          function takeOwnership(uint256 _tokenId) public {
            require(zombieApprovals[_tokenId] == msg.sender);
            address owner = ownerOf(_tokenId);
            _transfer(owner, msg.sender, _tokenId);
          }
        }
        ```
        

### 마무리

- 토큰, ERC721 표준, 그리고 거래할 수 있는 자산/좀비
- 라이브러리와 이를 사용하는 방법
- SafeMath 라이브러리를 사용하여 오버플로우와 언더플로우를 막는 방법
- 코드에 주석을 추가하는 방법과 natspec 표준