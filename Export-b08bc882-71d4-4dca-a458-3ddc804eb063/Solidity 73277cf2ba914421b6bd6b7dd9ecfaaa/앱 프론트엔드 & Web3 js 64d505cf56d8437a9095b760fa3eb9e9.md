# 앱 프론트엔드 & Web3.js

### ****Web3.js 소개****

- ****Web3.js****
    - 이더리움 네트워크는 노드로 구성, 각 노드는 블록체인의 복사본을 가지고 있음
    - 스마트 컨트랙트의 함수를 실행하고자 하면, 이 노드들 중 하나에 질의를 보내 내용 전달
    1. 스마트 컨트랙트의 주소
    2. 실행하고자 하는 함수, 그리고
    3. 그 함수에 전달하고자 하는 변수들
    - 이더리움 노드들은 ***SON-RPC***라고 불리는 언어로만 소통 가능
        - 이는 사람이 읽기 불편
        
        ```json
        
        {"jsonrpc":"2.0","method":"eth_sendTransaction","params":[{"from":"0xb60e8dd61c5d32be8058bb8eb970870f07233155","to":"0xd46e8dd67c5d32be8058bb8eb970870f07244567","gas":"0x76c0","gasPrice":"0x9184e72a000","value":"0x9184e72a","data":"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"}],"id":1}
        ```
        
    - Web3.js는 이런 질의를 몰라도 자바스크립트 인터페이스로 상호작용함
        
        ```jsx
        CryptoZombies.methods.createRandomZombie("Vitalik Nakamoto 🤔")
          .send({ from: "0xb60e8dd61c5d32be8058bb8eb970870f07233155", gas: "3000000" })
        ```
        
- 시작하기
    - 패키지 도구를 써서 Web3.js를 추가할 수있음
        
        ```jsx
        // NPM을 사용할 때
        npm install web3
        
        // Yarn을 사용할 때
        yarn add web3
        
        // Bower를 사용할 때
        bower install web3
        
        // ...기타 등등.
        ```
        
        - 단순히 [github](https://github.com/ethereum/web3.js/blob/1.0/dist/web3.min.js)에서 간략화된 `.js`파일을 다운로드하고 자네 프로젝트에 포함시킬 수도 있음.
        
        ```jsx
        <script language="javascript" type="text/javascript" src="web3.min.js"></script>
        ```
        
- 예제)`index.html`과 같은 경로의 폴더에 `web3.min.js`의 복사본을 가지고 있다고 가정
    
    1. 위의 스크립트 태그를 우리의 프로젝트에 복사/붙여넣기 하여 `web3.js`를 사용할 수 있도록 만들게. 
    
    - 예제 코드
        
        ```jsx
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>CryptoZombies front-end</title>
            <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
            <!-- 여기에 web3.js를 포함하게. -->
            <script language="javascript" type="text/javascript" src="web3.min.js"></script>
          </head>
          <body>
        
          </body>
        </html>
        ```
        

### Web3 프로바이더(Provider)

- ***Web3 프로바이더(Provider)***
    - 이더리움은 똑같은 데이터의 복사본을 공유하는 *노드*들로 구성
    - Web3.js에서 Web3프로바이더를 설정하는 것은 코드에 읽기와 쓰기를 처리하려면 어떤 노드와 통신을 해야 하는지 설정하는 것.
        - 전통적인 웹 앱에서 API호출을 위해 원격 웹 서버의 URL을 설정하는 것과 같음
    - 나만의 이더리움 노드를 프로바이더로 운영 가능
    - ***`Infura` :* DApp의 사용자들을 위해 자네만의 이더리움 노드를 운영할 필요가 없도록 하기 위해 사용할 수 있는 서비스**
- ****Infura****
    - Infura는 빠른 읽기를 위한 캐시 계층을 포함하는 다수의 이더리움 노드를 운영하는 서비스.
    - 접근을 위한 API를 무료로 사용
    - Infura를 프로바이더로 사용하면, 이더리움을 설치하고 계속 유지할 필요 없이 이더리움 블록체인과 메세지를 확실히 주고받을 수 있음.
    - 다음과 같이 Web3에 Web3 프로바이더로 Infura를 쓰도록 설정
    
    ```jsx
    var web3 = new Web3(new Web3.providers.WebsocketProvider("wss://mainnet.infura.io/ws"));
    ```
    
    - 많은 사용자들이 우리의 DApp을 사용할 것이기에(이 사용자들은 단순히 읽기만 하는 게 아니라 블록체인에 뭔가 쓰기도 할 것이기에) 이 사용자들이 그들의 개인 키로 트랜잭션에 서명을 할 수있도록 해야함
    
    > *참고: 이더리움(그리고 일반적으로 블록체인)은 트랜잭션에 전자 서명을 하기 위해 공개/개인 키 쌍을 사용하네. 말하자면 전자 서명을 위해 엄청나게 안전한 비밀번호 같은 것이지. 이런 방식으로 내가 만약 블록체인에서 어떤 데이터를 변경하면, 나의 공개 키를 통해 내가 거기 서명을 한 사람이라고 **증명**할 수 있네 - 하지만 아무도 내 개인 키를 모르기 때문에, 내 트랜잭션을 누구도 위조할 수 없지.*
    > 
    - 보안을 잘 모른다면 사용자들의 개인 키를 관리하는것은 어려움
        - ***메타마스크(Metamask) :*** 이를 대신 처리해주는 서비스
- ***메타마스크(Metamask)***
    - 메타마스크는 사용자들이 이더리움 계정과 개인 키를 안전하게 관리할 수있게 해주는 크롬과 파이어폭스의 브라우저 확장 프로그램
    - 해당 계정들을 써서 Web3.js를 사용하는 웹사이트들과 상호작용을 할 수 있도록 해줌
    
    > ***참고**: 메타마스크는 내부적으로 Infura의 서버를 Web3 프로바이더로 사용하네. 위에서 우리가 했던 것처럼 말이야 - 하지만 사용자들에게 그들만의 Web3 프로바이더를 선택할 수 있는 옵션을 주기도 하지. 즉 메타마스크의 Web3 프로바이더를 사용하면, 사용자에게 선택권을 주는 것이기도 하면서 자네 앱에서 걱정할 거리를 하나 줄일 수 있지.*
    > 
- ****메타마스크의 Web3 프로바이더 사용하기****
    - 메타마스크는 `web3`라는 전역 자바스크립트 객체를 통해 브라우저에 Web3 프로바이더를 주입
    - 앱에서는 `web3`가 존재하는지 확인하고, 만약 존재한다면 `web3.currentProvider`를 프로바이더로서 사용
    - 메타마스크에서 제공하는 템플릿 코드 : 사용자가 메타마스크를 설치했는지 확인하고 설치가 안 된 경우 우리 앱을 사용하려면 메타마스크를 설치해야 한다고 알려줌
    
    ```jsx
    window.addEventListener('load', function() {
    
      // Web3가 브라우저에 주입되었는지 확인(Mist/MetaMask)
      if (typeof web3 !== 'undefined') {
        // Mist/MetaMask의 프로바이더 사용
        web3js = new Web3(web3.currentProvider);
      } else {
        // 사용자가 Metamask를 설치하지 않은 경우에 대해 처리
        // 사용자들에게 Metamask를 설치하라는 등의 메세지를 보여줄 것
      }
    
      // 이제 자네 앱을 시작하고 web3에 자유롭게 접근할 수 있네:
      startApp()
    
    })
    ```
    
    > *참고: 메타마스크 말고도 사용자들이 쓸 수 있는 다른 개인 키 관리 프로그램도 있네. **미스트(Mist)** 웹 브라우저 같은 것들이지. 하지만, 그것들도 모두 `web3` 변수를 주입하는 동일한 형태를 사용하네. 그러니 사용자들이 다른 프로그램을 쓰더라도 여기서 우리가 설명하는 방식으로 사용자의 Web3 프로바이더를 인식할 수 있을 것이네.*
    > 
- 예제)
    
    1. 위에서 말한 메타마스크를 인식하기 위한 템플릿 코드를 코드를 복사/붙여넣기 하게. `window.addEventListener`로 시작하는 블록이네. 
    
    - 예제 코드
        
        ```jsx
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>CryptoZombies front-end</title>
            <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
            <script language="javascript" type="text/javascript" src="web3.min.js"></script>
          </head>
          <body>
        
            <script>
              // 여기서 시작하게.
              window.addEventListener('load', function() {
        
              // Web3가 브라우저에 주입되었는지 확인(Mist/MetaMask)
              if (typeof web3 !== 'undefined') {
              // Mist/MetaMask의 프로바이더 사용
                web3js = new Web3(web3.currentProvider);
              } else {
              // 사용자가 Metamask를 설치하지 않은 경우에 대해 처리
              // 사용자들에게 Metamask를 설치하라는 등의 메세지를 보여줄 것
              }
        
              // 이제 자네 앱을 시작하고 web3에 자유롭게 접근할 수 있네:
              startApp()
        
        })
            </script>
          </body>
        </html>
        ```
        

### 컨트랙트와 대화하기

- Web3.js는 스마트 컨트랙트와 통신을 위해 2가지를 필요로 할 것: 
컨트랙트의 **_주소_**와 ***ABI***
- ****컨트랙트 주소****
    - 스마트 컨트랙트를 모두 작성한 후, 그걸 컴파일한 후 이더리움에 배포
    - 컨트랙트를 배포한 후, 해당 컨트랙트는 영원히 존재하는, 이더리움 상에서 고정된 주소를 얻음
    - ex) 이더리움 메인넷에서 크립토키티의 주소는
     `0x06012c8cf97BEaD5deAe237070F9587f8E7A266d` 였음
- ****컨트랙트 ABI****
    - ABI는 Application Binary Interface의 줄임말
    - 기본적으로 JSON 형태로 컨트랙트의 메소드를 표현.
    - 컨트랙트가 이해할 수 있도록 하려면 Web3.js가 어떤 형태로 함수 호출을 해야 하는지 알려줘야함
    - 이더리움에 배포하기 위해 컨트랙트를 컴파일할 때, 솔리디티 컴파일러가 자네에게 ABI를 줌
        - 컨트랙트 주소와 함께 이를 복사하여 저장.
    - ABI를 컴파일하여 `cryptozombies_abi.js`라는 파일의 `cryptoZombiesABI`변수에 저장
        - `cryptozombies_abi.js`를 우리 프로젝트에 포함하면, 해당 변수를 사용하여 크립토좀비 ABI에 접근할 수 있을 것
- ****Web3.js 컨트랙트 인스턴스화하기****
    - 컨트랙트의 주소와 ABI를 얻고 나면, 자네는 다음과 같이 Web3에서 인스턴스화
    
    ```jsx
    // myContract 인스턴스화
    var myContract = new web3js.eth.Contract(myABI, myContractAddress);
    ```
    
- 예제)
    1. 우리 문서의 `<head>`에서, `cryptozombies_abi.js`를 포함하도록 또 다른 스크립트 태그를 써서 우리가 ABI 정의를 우리 프로젝트에 가져올 수 있도록 하게.
    2. `<body>`의 `<script>` 태그 시작 부분에서, `cryptoZombies`라는 이름으로 `var`를 선언하고 어떤 값도 아직 핟당은 하지 말게. 추후 이 변수를 우리의 인스턴스화된 컨트랙트를 저장하는 데에 사용할 것이네.
    3. 다음으로, `startApp()`이라는 이름으로 `function`을 만들게. 내용 부분은 다음 2단계로 나누어 채울 것이네.
    4. `startApp()`이 처음으로 해야 할 것은 `cryptoZombiesAddress`라는 이름으로 `var`를 선언하고 여기에 `"YOUR_CONTRACT_ADDRESS"`를 할당하는 것이네(이는 메인넷에서 크립토좀비 컨트랙트의 주소이네).
    5. 마지막으로, 우리 컨트랙트를 인스턴화하도록 하지. 우리가 위의 예제 코드에서 했던 것처럼 `cryptoZombies`에 새 `web3js.eth.Contract`를 할당하게(스크립트 태그를 통해 가져오는 `cryptoZombiesABI`와 위의 `cryptoZombiesAddress`를 사용하게). 
- 예제 코드
    
    ```jsx
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <title>CryptoZombies front-end</title>
        <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script language="javascript" type="text/javascript" src="web3.min.js"></script>
        <!-- 1. 여기에 cryptozombies_abi.js를 포함하게 -->
        <script language="javascript" type="text/javascript" src="cryptozombies_abi.js"></script>
      </head>
      <body>
    
        <script>
          // 2. 여기서 코딩을 시작하게
          var cryptoZombies;
    
          function startApp(){
            var cryptoZombiesAddress = "YOUR_CONTRACT_ADDRESS";
            cryptoZombies = new web3js.eth.Contract(cryptoZombiesABI, cryptoZombiesAddress);
          }
    
          window.addEventListener('load', function() {
    
            // Web3가 브라우저에 주입되었는지 확인(Mist/MetaMask)
            if (typeof web3 !== 'undefined') {
              // Mist/MetaMask의 프로바이더 사용
              web3js = new Web3(web3.currentProvider);
            } else {
              // 사용자가 Metamask를 설치하지 않은 경우에 대해 처리
              // 사용자들에게 Metamask를 설치하라는 등의 메세지를 보여줄 것
            }
    
            // 이제 자네 앱을 시작하고 web3에 자유롭게 접근할 수 있네:
            startApp()
    
          })
        </script>
      </body>
    </html>
    ```
    

### 컨트랙트 함수 호출

- Web3.js는 컨트랙트의 함수를 호출하기 위해 우리가 사용할 두 개의 메소드: 
`call`과 `send`
- Call
    - `call`은 `view`와 `pure`함수를 위해 사용
    - 로컬 노드에서만 실행하고, 블록체인에 트랜잭션을 만들지 않음
    
    > ***복습:** `view`와 `pure` 함수는 읽기 전용이고 블록체인에서 상태를 변경하지 않네. 가스를 전혀 소모하지 않고, 메타마스크에서 트랜잭션에 서명하라고 사용자에게 창을 띄우지도 않지.*
    > 
    - Web3.js를 사용하여, 다음과 같이 `123`을 매개 변수로 `myMethod`라는 이름의 함수를 `call`
    
    ```jsx
    myContract.methods.myMethod(123).call()
    ```
    
- Send
    - `send`는 트랜잭션을 만들고 블록체인 상의 데이터를 변경
    - `view`와 `pure`가 아닌 모든 함수에 대해 `send`를 사용해야 하는 것
    
    > ***참고:** 트랜잭션을 `send`하는 것은 사용자에게 가스를 지불하도록 하고, 메타마스크에서 트랜잭션에 서명하라고 창을 띄울 것이네. Web3 프로바이더로 메타마스크를 사용할 때, `send()`를 호출하면 자동으로 이 모든 것이 이루어지고, 우리의 코드에 어떤 특별한 것도 추가할 필요가 없지.*
    > 
    - Web3.js를 사용하여, 다음과 같이 `123`을 매개 변수로 `myMethod`라는 이름의 함수를 호출하는 트랜잭션을 `send`
    
    ```jsx
    myContract.methods.myMethod(123).send()
    ```
    
- 좀비 데이터 받기
    - 컨트랙트에서 데이터에 접근하기 위해 `call`을 사용하는 실제 예제
    - 좀비 배열을 `public`으로 만들었던 것
    
    ```solidity
    Zombie[] public zombies;
    ```
    
    - 솔리디티에서, `public`으로 변수를 선언하면 자동으로 같은 이름의 퍼블릭 "getter" 함수를 만듬. ID `15`인 좀비를 찾길 원한다면, 변수를 함수인 것처럼 호출할 수 있음
        - ex) `zombies(15)`
    - 프론트엔드에서 좀비 ID를 받아 해당 좀비에 대해 컨트랙트에 질의를 보내고, 결과를 반환하는 자바스크립트 함수를 작성하는 방법
    
    > *참고: 이번 레슨에서 우리가 사용하는 모든 코드 예제들은 콜백 대신 Promise를 사용하는 Web3.js **1.0 버전**을 사용하고 있네. 자네가 온라인에서 찾을 수 있는 다른 많은 튜토리얼들에서는 Web3.js의 이전 버전을 사용하고 있네. 1.0 버전에서 문법이 많이 바뀌었으니, 만약 자네가 다른 튜토리얼에서 코드를 복사해온다면 같은 버전을 사용하고 있는지 확인!*
    > 
    
    [Javascript Promise](https://www.notion.so/Javascript-Promise-f7df15382d3744869b59dc27ffb97745) 
    
    ```jsx
    function getZombieDetails(id) {
      return cryptoZombies.methods.zombies(id).call()
    }
    
    // 함수를 호출하고 결과를 가지고 무언가를 처리:
    getZombieDetails(15)
    .then(function(result) {
      console.log("Zombie 15: " + JSON.stringify(result));
    });
    ```
    
    - `cryptoZombies.methods.zombies(id).call()`는 Web3 프로바이더와 통신하여 우리 컨트랙트의 `Zombie[] public zombies`에서 인덱스가 `id`인 좀비를 반환하도록
        - 외부 서버로 API 호출을 하는 것처럼 **비동기**적으로 일어남
    - Web3는 여기서 Promise를 반환
    - Promise가 만들어지면(Web3 프로바이더로부터 응답을 받았다는 것을 의미) 예제 코드는 `then`문장을 실행하고, 여기서 `result`를 콘솔에 로그로 기록
    - `result`는 다음과 같이 생긴 자바스크립트 객체
        
        ```jsx
        {
          "name": "H4XF13LD MORRIS'S COOLER OLDER BROTHER",
          "dna": "1337133713371337",
          "level": "9999",
          "readyTime": "1522498671",
          "winCount": "999999999",
          "lossCount": "0" // Obviously.
        }
        ```
        
        - 이 객체를 해석하기 위한 프론트엔드 로직을 만들어 의미 있는 방향으로 이 객체를 프론트엔드에 표시
- 예제)
    1. `zombieToOwner`와 비슷한 함수를 만들도록 하지. `ZombieFactory.sol`을 기억한다면, 다음과 같이 생긴 매핑이 생각날 것이네:
        
        ```solidity
        mapping (uint => address) public zombieToOwner;
        ```
        
        `zombieToOwner`라는 이름으로 자바스크립트 함수를 정의하게. 위의 `getZombieDetails`와 비슷하게, 이 함수는 `id`를 매개 변수로 받고 우리 컨트랙트의 `zombieToOwner`에 대한 Web3.js `call`을 반환할 것이네.
        
    2. 그 아래에, 세 번째 함수로 `getZombiesByOwner`를 만들게. `ZombieHelper.sol`이 기억난다면, 다음과 같이 생긴 함수가 생각날 것이네:
        
        ```solidity
        function getZombiesByOwner(address _owner)
        ```
        
        우리의 `getZombiesByOwner` 함수는 `owner`를 매개 변수로 받고, `getZombiesByOwner`에 대한 Web3.js `call`을 반환할 것이네. 
        
    - 예제 코드
        
        ```jsx
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>CryptoZombies front-end</title>
            <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
            <script language="javascript" type="text/javascript" src="web3.min.js"></script>
            <script language="javascript" type="text/javascript" src="cryptozombies_abi.js"></script>
          </head>
          <body>
        
            <script>
              var cryptoZombies;
        
              function startApp() {
                var cryptoZombiesAddress = "YOUR_CONTRACT_ADDRESS";
                cryptoZombies = new web3js.eth.Contract(cryptoZombiesABI, cryptoZombiesAddress);
              }
        
              function getZombieDetails(id) {
                return cryptoZombies.methods.zombies(id).call()
              }
        
              // 1. 여기에 `zombieToOwner`를 정의하게.
              function zombieToOwner(id){
                return cryptoZombies.methods.zombieToOwner(id).call()
              }
        
              // 2. 여기에 `getZombiesByOwner`를 정의하게.
              function getZombiesByOwner(owner){
                return cryptoZombies.methods.getZombiesByOwner(owner).call()
              }
        
              window.addEventListener('load', function() {
        
                // Web3가 브라우저에 주입되었는지 확인(Mist/MetaMask)
                if (typeof web3 !== 'undefined') {
                  // Mist/MetaMask의 프로바이더 사용
                  web3js = new Web3(web3.currentProvider);
                } else {
                  // 사용자가 Metamask를 설치하지 않은 경우에 대해 처리
                  // 사용자들에게 Metamask를 설치하라는 등의 메세지를 보여줄 것
                }
        
                // 이제 자네 앱을 시작하고 web3에 자유롭게 접근할 수 있네:
                startApp()
        
              })
            </script>
          </body>
        </html>
        ```
        

### ****메타마스크 & 계정****

우리 앱의 홈페이지에 사용자의 전체 좀비 군대를 보여주고 싶다고 가정. 현재 사용자가 가지고 있는 모든 좀비들의 ID를 찾기 위해 우리는 분명 첫 번째로 `getZombiesByOwner(owner)`함수를 사용해야 할 것.

하지만 우리의 솔리디티 컨트랙트는 `owner`에 솔리디티 `address`를 보내도록 되어 있음. 그렇다면 우리가 어떻게 우리 앱을 사용하는 사용자의 주소를 알 수 있나?

- ****메타마스크에서 사용자 계정 가져오기****
    - 메타마스크는 확장 프로그램 안에서 사용자들이 다수의 계정을 관리할 수 있도록 해주네.
    - 우리는 주입되어 있는 `web3`변수에 현재 활성화된 계정이 무엇인지 다음처럼 확인할 수 있지:
    
    ```jsx
    var userAccount = web3.eth.accounts[0]
    ```
    
    - 사용자가 언제든지 메타마스크에서 활성화된 계정을 바꿀 수 있기 때문에, 우리 앱은 이 변수의 값이 바뀌었는지 확인하기 위해 계속 감시를 하고 값이 바뀌면 그에 따라 UI를 업데이트해야 할 것이네. 예를 들어, 사용자들의 홈페이지에서 그들의 좀비 군대를 표시하고 싶다면, 메타마스크에서 계정을 바꾸었을 때 바뀐 계정에 대한 좀비 군대를 보여주기 위해 페이지를 업데이트해야 할 것이네.
    - 이를 위해 다음과 같이 `setInterval`을 쓸 수 있네:
    
    ```jsx
    var accountInterval = setInterval(function() {
      // 계정이 바뀌었는지 확인
      if (web3.eth.accounts[0] !== userAccount) {
        userAccount = web3.eth.accounts[0];
        // 새 계정에 대한 UI로 업데이트하기 위한 함수 호출
        updateInterface();
      }
    }, 100);
    ```
    
    - 여기서는 `userAccount`가 여전히 `web3.eth.accounts[0]`과 같은지 확인하기 위해 100밀리초마다 확인하고 있네(즉 사용자가 해당 계정을 활성화해놓았는지 확인하는 것이지). 그렇지 않다면, `userAccount`에 현재 활성화된 계정을 다시 할당하고, 화면을 업데이트하기 위한 함수를 호출하네.
- 예제) 페이지가 처음 로드될 때 사용자의 좀비 군대를 우리 앱에서 보여줄 수 있게 만들어 보도록 하지. 그리고 활성화 계정이 바뀌면 화면을 갱신할 수 있게 감시를 할 것이네.
    1. `userAccount`라는 이름으로 `var`를 선언하게. 값을 할당하지는 않도록 하게.
    2. `startApp()`의 마지막 부분에서, 위의 `accountInterval` 예제 코드를 복사/붙여넣기 하게.
    3. `updateInterface();` 줄을 `getZombiesByOwner`를 호출하는 것으로 교체하고 `userAccount`를 전달하게.
    4. `getZombiesByOwner` 이후 `then`절을 이어 결과값을 `displayZombies`라는 이름의 함수로 전달하게(구문은 다음과 같네: `.then(displayZombies);`).
        
        `displayZombies`라는 함수를 아직 만들지 않았지만, 다음 챕터에서 이를 구현할 것이네. 
        
- 예제 코드
    
    ```jsx
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <title>CryptoZombies front-end</title>
        <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script language="javascript" type="text/javascript" src="web3.min.js"></script>
        <script language="javascript" type="text/javascript" src="cryptozombies_abi.js"></script>
      </head>
      <body>
    
        <script>
          var cryptoZombies;
          // 1. 여기에 `userAccount`를 선언하게.
          var userAccount;
    
          function startApp() {
            var cryptoZombiesAddress = "YOUR_CONTRACT_ADDRESS";
            cryptoZombies = new web3js.eth.Contract(cryptoZombiesABI, cryptoZombiesAddress);
    
            // 2. 여기에 `setInterval` 코드를 만들게.
            var accountInterval = setInterval(function() {
            // 계정이 바뀌었는지 확인
              if (web3.eth.accounts[0] !== userAccount) {
                userAccount = web3.eth.accounts[0];
              // 새 계정에 대한 UI로 업데이트하기 위한 함수 호출
                getZombiesByOwner(userAccount).then(displayZombies);
              }
            }, 100);
          }
    
          function getZombieDetails(id) {
            return cryptoZombies.methods.zombies(id).call()
          }
    
          function zombieToOwner(id) {
            return cryptoZombies.methods.zombieToOwner(id).call()
          }
    
          function getZombiesByOwner(owner) {
            return cryptoZombies.methods.getZombiesByOwner(owner).call()
          }
    
          window.addEventListener('load', function() {
    
            // Web3가 브라우저에 주입되었는지 확인(Mist/MetaMask)
            if (typeof web3 !== 'undefined') {
              // Mist/MetaMask의 프로바이더 사용
              web3js = new Web3(web3.currentProvider);
            } else {
              // 사용자가 Metamask를 설치하지 않은 경우에 대해 처리
              // 사용자들에게 Metamask를 설치하라는 등의 메세지를 보여줄 것
            }
    
            // 이제 자네 앱을 시작하고 web3에 자유롭게 접근할 수 있네:
            startApp()
    
          })
        </script>
      </body>
    </html>
    ```
    

### ****좀비 군대 보여주기****

CryptoZombies.io의 초점을 이더리움과 스마트 컨트랙트에 맞추기 위해,  jQuery를 이용한 간단한 예제를 통해 어떻게 스마트 컨트랙트에서 전달받은 데이터를 파싱하고 표현할 수 있을지 보여줄 것.

- ****좀비 데이터 보여주기 - 간단한 예제****
    - 문서의 내용에 빈 `<div id="zombies"></div>`와 빈 `displayZombies` 함수를 추가.
    - 지난 챕터에서 우리가 `startApp()` 내에서 `getZombiesByOwner`의 호출 결과를 써서 호출한 `displayZombies`를 상기해보게. 그 함수의 결과로 아래와 같이 생긴 좀비 ID 배열을 전달받을 수 있을 걸세. 따라서 `displayZombies`함수는 다음과 같은 것을 할 것이네:
    1. 먼저 이미 무언가가 `#zombies` div의 안에 들어 있다면 이 div의 내용을 비우게(이렇게 하면 사용자가 그들의 활성화된 MetaMask 계정을 변경하면 새로운 좀비 군대를 로딩하기 전에 기존의 것을 삭제할 것이네).
    2. 반복을 통해 각 `id`마다 `getZombieDetails(id)`를 호출해서 우리의 스마트 컨트랙트에서 좀비에 대한 모든 정보를 찾게. 그리고서
    3. 화면에 표시하기 위해 HTML 템플릿에 좀비에 대한 정보를 집어넣고, 해당 템플릿을 `#zombies` div에 붙여넣게. 
    
    ```jsx
    // 우리 컨트랙트에서 좀비 상세 정보를 찾아, `zombie` 객체 반환
    getZombieDetails(id)
    .then(function(zombie) {
      // HTML에 변수를 넣기 위해 ES6의 "template literal" 사용
      // 각각을 #zombies div에 붙여넣기
      $("#zombies").append(`<div class="zombie">
        <ul>
          <li>Name: ${zombie.name}</li>
          <li>DNA: ${zombie.dna}</li>
          <li>Level: ${zombie.level}</li>
          <li>Wins: ${zombie.winCount}</li>
          <li>Losses: ${zombie.lossCount}</li>
          <li>Ready Time: ${zombie.readyTime}</li>
        </ul>
      </div>`);
    });
    ```
    
- ****좀비 스프라이트는 어떻게 표현하나요?****
    
    위 예제에서 우리는 DNA를 문자열로 간단히 표현해 보았네. 하지만 자네의 DApp에서는 이것을 이미지로 바꿔서 자네의 좀비를 표현하고 싶을 걸세. 우린 DNA 문자열을 부분 문자열로 나누고, 모든 2자리 숫자를 이미지에 대응시켜 아래와 같이 이 작업을 처리했었네: 
    
    ```jsx
    // 좀비의 머리를 표현하는 1-7의 정수 얻기
    var head = parseInt(zombie.dna.substring(0, 2)) % 7 + 1
    
    // 순차적인 파일 이름으로 7개의 머리 이미지를 가지고 있네:
    var headSrc = "../assets/zombieparts/head-" + head + ".png"
    ```
    
    각 컴포넌트는 CSS의 절대 좌표 포지셔닝을 이용해 다른 이미지 위에 위치할 걸세.
    
    만약 자네가 우리의 정확한 구현을 보고싶다면, 좀비를 표현하기 위해 우리가 사용한 Vue.js 컴포넌트 소스를 공개해놓았네. 그건 [여기](https://github.com/loomnetwork/zombie-char-component)에서 볼 수 있네.
    
    하지만 저 파일에는 많은 코드가 포함되어 있기 때문에, 그건 튜토리얼의 범주 밖이라네. 우린 위에서 본 매우 간단한 jQuery 구현에 집중할 것이고, 좀 더 아름다운 표현은 자네에게 숙제로 남겨두겠네 😉.
    
- 예제)
    1. 우리가 처음 할 것은 `#zombies` div를 비우는 것이네. jQuery에서는 `$("#zombies").empty();`를 이용해서 이를 처리할 수 있네.
    2. 다음으로, for 반복문을 이용해 모든 id에 접근해야 하네: `for (id of ids) {`
    3. for 반복문에서 각 id에 대해 `getZombieDetails(id)`라는 코드 블록을 복사/붙여넣기한 다음 `$("#zombies").append(...)`를 사용하여 HTML에 추가하게. 
    - 에제 코드
        
        ```jsx
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>CryptoZombies front-end</title>
            <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
            <script language="javascript" type="text/javascript" src="web3.min.js"></script>
            <script language="javascript" type="text/javascript" src="cryptozombies_abi.js"></script>
          </head>
          <body>
            <div id="zombies"></div>
        
            <script>
              var cryptoZombies;
              var userAccount;
        
              function startApp() {
                var cryptoZombiesAddress = "YOUR_CONTRACT_ADDRESS";
                cryptoZombies = new web3js.eth.Contract(cryptoZombiesABI, cryptoZombiesAddress);
        
                var accountInterval = setInterval(function() {
                  // 계정이 바뀌었는지 확인
                  if (web3.eth.accounts[0] !== userAccount) {
                    userAccount = web3.eth.accounts[0];
                    // 새 계정에 대한 UI로 업데이트하기 위한 함수 호출
                    getZombiesByOwner(userAccount)
                    .then(displayZombies);
                  }
                }, 100);
              }
        
              function displayZombies(ids) {
                $("#zombies").empty();
                for (id of ids) {
                  getZombieDetails(id)
                  .then(function(zombie) {
        
                    $("#zombies").append(`<div class="zombie">
                      <ul>
                        <li>Name: ${zombie.name}</li>
                        <li>DNA: ${zombie.dna}</li>
                        <li>Level: ${zombie.level}</li>
                        <li>Wins: ${zombie.winCount}</li>
                        <li>Losses: ${zombie.lossCount}</li>
                        <li>Ready Time: ${zombie.readyTime}</li>
                      </ul>
                    </div>`);
                  })
                }
              }
        
              function getZombieDetails(id) {
                return cryptoZombies.methods.zombies(id).call()
              }
        
              function zombieToOwner(id) {
                return cryptoZombies.methods.zombieToOwner(id).call()
              }
        
              function getZombiesByOwner(owner) {
                return cryptoZombies.methods.getZombiesByOwner(owner).call()
              }
        
              window.addEventListener('load', function() {
        
                // Web3가 브라우저에 주입되었는지 확인(Mist/MetaMask)
                if (typeof web3 !== 'undefined') {
                  // Mist/MetaMask의 프로바이더 사용
                  web3js = new Web3(web3.currentProvider);
                } else {
                  // 사용자가 Metamask를 설치하지 않은 경우에 대해 처리
                  // 사용자들에게 Metamask를 설치하라는 등의 메세지를 보여줄 것
                }
        
                // 이제 자네 앱을 시작하고 web3에 자유롭게 접근할 수 있네:
                startApp()
        
              })
            </script>
          </body>
        </html>
        ```
        

### ****트랜잭션 보내기****

이제 `send` 함수를 이용해 스마트 컨트랙트의 데이터를 변경하는 방법을 살펴보도록 하지.

이 함수에는 `call` 함수와는 꽤 다른 부분이 있네:

1. 트랜잭션을 전송(`send`)하려면 함수를 호출한 사람의 `from` 주소가 필요하네(솔리디티 코드에서는 `msg.sender`가 될 것이네). 이는 우리 DApp의 사용자가 되어야 할 것이니, 메타마스크가 나타나 그들에게 서명을 하도록 할걸세.
2. 트랜잭션 전송(`send`)은 가스를 소모하네.
3. 사용자가 트랜잭션 전송을 하고 난 후 실제로 블록체인에 적용될 때까지는 상당한 지연이 발생할 것이네. 트랜잭션이 블록에 포함될 때까지 기다려야 하는데, 이더리움의 평균 블록 시간이 15초이기 때문이지. 만약 이더리움에 보류 중인 거래가 많거나 사용자가 가스 가격을 지나치게 낮게 보낼 경우, 우리 트랜잭션이 블록에 포함되길 기다려야 하고, 이는 몇 분씩 걸릴 수 있네.

그러니 이 코드의 비동기적 특성을 다루기 위한 로직이 필요하게 될 걸세.

- ****좀비 만들기****
    - 호출할 우리 컨트랙트 내의 첫번째 함수를 예제로 살핌: `createRandomZombie`
    - 여기서 우리 컨트랙트의 솔리디티 코드를 다시 확인:
    
    ```solidity
    function createRandomZombie(string _name) public {
      require(ownerZombieCount[msg.sender] == 0);
      uint randDna = _generateRandomDna(_name);
      randDna = randDna - randDna % 100;
      _createZombie(_name, randDna);
    }
    ```
    
    - 다음은 메타마스크를 사용해 Web3.js에서 위 함수를 호출하는 방법의 예제일세:
    
    ```jsx
    function createRandomZombie(name) {
      // 시간이 꽤 걸릴 수 있으니, 트랜잭션이 보내졌다는 것을
      // 유저가 알 수 있도록 UI를 업데이트해야 함
      $("#txStatus").text("Creating new zombie on the blockchain. This may take a while...");
      // 우리 컨트랙트에 전송하기:
      return CryptoZombies.methods.createRandomZombie(name)
      .send({ from: userAccount })
      .on("receipt", function(receipt) {
        $("#txStatus").text("Successfully created " + name + "!");
        // 블록체인에 트랜잭션이 반영되었으며, UI를 다시 그려야 함
        getZombiesByOwner(userAccount).then(displayZombies);
      })
      .on("error", function(error) {
        // 사용자들에게 트랜잭션이 실패했음을 알려주기 위한 처리
        $("#txStatus").text(error);
      });
    }
    ```
    
    - 위 함수는 우리의 Web3 프로바이더에게 트랜잭션을 전송(`send`)하고, 몇 가지 이벤트 리스너들을 연결하네:
        - `receipt`는 트랜잭션이 이더리움의 블록에 포함될 때, 즉 좀비가 생성되고 우리의 컨트랙트에 저장되었을 때 발생하게 되네.
        - `error`는 트랜잭션이 블럭에 포함되지 못했을 때, 예를 들어 사용자가 충분한 가스를 전송하지 않았을 때 발생하게 되네. 우리는 우리의 UI를 통해 사용자에게 트랜잭션이 전송되지 않았음을 알리고, 다시 시도할 수 있도록 할 것이네.
        
        > *참고: 자네가 `send`를 호출할 때 `gas`와 `gasPrice`를 선택적으로 지정할 수 있네. `.send({ from: userAccount, gas: 3000000 })`와 같이 말이야. 만약 지정하지 않는다면, 메타마스크는 사용자가 이 값들을 선택할 수 있도록 할 걸세.*
        > 
- 예제) ID가 `txStatus`인 `div`를 추가해 놓았네. 우린 이 div를 사용해 우리 트랜잭션의 상태를 사용자에게 메시지로 알릴 수 있네.
    1. `displayZombies` 아래에 위의 `createRandomZombie`를 복사/붙여넣기 하게.
    2. `feedOnKitty` 라는 또 다른 함수를 구현해보겠네.
        
        `feedOnKitty`를 호출하는 로직은 거의 동일하네 - 함수를 호출하는 트랜잭션을 보내고, 트랜잭션이 성공하면 새로운 좀비가 생성될 것이네. 그러니 성공 후에는 UI를 다시 그려야 할 것이네.
        
        `createRandomZombie`를 그것 바로 아래에 복사하고, 다음과 같이 변경하게:
        
        a) 2개의 인자 `zombieId`와 `kittyId`를 받는 두 번째 함수 `feedOnKitty`를 호출하게.
        
        b) `#txStatus` 텍스트를 다음과 같이 업데이트하게: "Eating a kitty. This may take a while..."
        
        c) 우리 컨트랙트의 `feedOnKitty`를 호출하게 하고, 같은 2개의 인자를 전달하게.
        
        d) `#txStatus`에 성공 메세지로 "Ate a kitty and spawned a new Zombie!"를 쓰게. 
        
        - 예제 코드
            
            ```jsx
            <!DOCTYPE html>
            <html lang="en">
              <head>
                <meta charset="UTF-8">
                <title>CryptoZombies front-end</title>
                <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
                <script language="javascript" type="text/javascript" src="web3.min.js"></script>
                <script language="javascript" type="text/javascript" src="cryptozombies_abi.js"></script>
              </head>
              <body>
                <div id="txStatus"></div>
                <div id="zombies"></div>
            
                <script>
                  var cryptoZombies;
                  var userAccount;
            
                  function startApp() {
                    var cryptoZombiesAddress = "YOUR_CONTRACT_ADDRESS";
                    cryptoZombies = new web3js.eth.Contract(cryptoZombiesABI, cryptoZombiesAddress);
            
                    var accountInterval = setInterval(function() {
                      // 계정이 바뀌었는지 확인
                      if (web3.eth.accounts[0] !== userAccount) {
                        userAccount = web3.eth.accounts[0];
                        // 새 계정에 대한 UI로 업데이트하기 위한 함수 호출
                        getZombiesByOwner(userAccount)
                        .then(displayZombies);
                      }
                    }, 100);
                  }
            
                  function displayZombies(ids) {
                    $("#zombies").empty();
                    for (id of ids) {
                      // 우리 컨트랙트에서 좀비 상세 정보를 찾아, `zombie` 객체 반환
                      getZombieDetails(id)
                      .then(function(zombie) {
                        // HTML에 변수를 넣기 위해 ES6의 "template literal" 사용
                        // 각각을 #zombies div에 붙여넣기
                        $("#zombies").append(`<div class="zombie">
                          <ul>
                            <li>Name: ${zombie.name}</li>
                            <li>DNA: ${zombie.dna}</li>
                            <li>Level: ${zombie.level}</li>
                            <li>Wins: ${zombie.winCount}</li>
                            <li>Losses: ${zombie.lossCount}</li>
                            <li>Ready Time: ${zombie.readyTime}</li>
                          </ul>
                        </div>`);
                      });
                    }
                    function createRandomZombie(name) {
                      // 시간이 꽤 걸릴 수 있으니, 트랜잭션이 보내졌다는 것을
                      // 유저가 알 수 있도록 UI를 업데이트해야 함
                      $("#txStatus").text("Creating new zombie on the blockchain. This may take a while...");
                      // 우리 컨트랙트에 전송하기:
                      return CryptoZombies.methods.createRandomZombie(name)
                      .send({ from: userAccount })
                      .on("receipt", function(receipt) {
                        $("#txStatus").text("Successfully created " + name + "!");
                        // 블록체인에 트랜잭션이 반영되었으며, UI를 다시 그려야 함
                        getZombiesByOwner(userAccount).then(displayZombies);
                      })
                      .on("error", function(error) {
                        // 사용자들에게 트랜잭션이 실패했음을 알려주기 위한 처리
                        $("#txStatus").text(error);
                      });
                  }
            
                  // Start here
                  function feedOnKitty(zombieId, kittyId) {
                      $("#txStatus").text("Eating a kitty. This may take a while...");
                      // 우리 컨트랙트에 전송하기:
                      return CryptoZombies.methods.feedOnKitty(zombieId, kittyId)
                      .send({ from: userAccount })
                      .on("receipt", function(receipt) {
                        $("#txStatus").text("Ate a kitty and spawned a new Zombie!");
                        // 블록체인에 트랜잭션이 반영되었으며, UI를 다시 그려야 함
                        getZombiesByOwner(userAccount).then(displayZombies);
                      })
                      .on("error", function(error) {
                        // 사용자들에게 트랜잭션이 실패했음을 알려주기 위한 처리
                        $("#txStatus").text(error);
                      });  
                  }
            
                  function getZombieDetails(id) {
                    return cryptoZombies.methods.zombies(id).call()
                  }
            
                  function zombieToOwner(id) {
                    return cryptoZombies.methods.zombieToOwner(id).call()
                  }
            
                  function getZombiesByOwner(owner) {
                    return cryptoZombies.methods.getZombiesByOwner(owner).call()
                  }
            
                  window.addEventListener('load', function() {
            
                    // Web3가 브라우저에 주입되었는지 확인(Mist/MetaMask)
                    if (typeof web3 !== 'undefined') {
                      // Mist/MetaMask의 프로바이더 사용
                      web3js = new Web3(web3.currentProvider);
                    } else {
                      // 사용자가 Metamask를 설치하지 않은 경우에 대해 처리
                      // 사용자들에게 Metamask를 설치하라는 등의 메세지를 보여줄 것
                    }
            
                    // 이제 자네 앱을 시작하고 web3에 자유롭게 접근할 수 있네:
                    startApp()
            
                  })
                </script>
              </body>
            </html>
            ```
            

### ****Payable 함수 호출하기****

Web3.js에서 특별한 처리가 필요한 다른 종류의 함수를 살펴보겠네 - 바로 `payable`함수

- ****레벨업!****
    - `ZombieHelper`
    를 다시 생각해보면, 우린 사용자가 레벨업할 수 있는 곳에 payable 함수를 추가했었네:
    
    ```solidity
    function levelUp(uint _zombieId) external payable {
      require(msg.value == levelUpFee);
      zombies[_zombieId].level++;
    }
    ```
    
    - 함수를 이용해 이더를 보내는 방법은 간단하지만, 이더가 아니라 wei로 얼마를 보낼지 정해야 하는 제한이 있네.
- ****Wei란?****
    - `wei`는 이더의 가장 작은 하위 단위이네 - 하나의 이더는 10^18개의 `wei`이지.
    
    ```jsx
    // 이렇게 하면 1 ETH를 Wei로 바꿀 것이네
    web3js.utils.toWei("1");
    ```
    
    - 우리 DApp에서, 우리는 `levelUpFee = 0.001 ether`로 설정했네. 그러니 `levelup` 함수를 호출할 때, 아래의 코드를 써서 사용자가 `0.001` 이더를 보내게 할 수 있네.
    
    ```jsx
    CryptoZombies.methods.levelUp(zombieId)
    .send({ from: userAccount, value: web3js.utils.toWei("0.001") })
    ```
    
- 예제 ) `levelUp`함수를 `feedOnKitty`아래에 추가해 보도록 하지. 코드는 `feedOnKitty`와 매우 비슷할 것이네.
    1. 함수는 1개의 매개 변수 `zombieId` 를 받을 것이네.
    2. 트랜잭션 전에 `txStatus` 텍스트로 `"좀비를 레벨업하는 중..."`을 표시해야 하네.
    3. 컨트랙트의 `levelUp`을 호출할 때, 위 예제처럼 `"0.001"` ETH를 `toWei`로 변환해서 보내야 하네.
    4. 성공하면 `"압도적인 힘! 좀비가 성공적으로 레벨업했습니다."` 텍스트를 표시해야 하네.
    5. 우린 `getZombiesByOwner`를 통해 스마트 컨트랙트에 질의를 하고 UI를 다시 그릴 필요가 **없네** - 이 경우에는 단지 좀비의 레벨만 변하기 때문이네. 
    - 예제 코드
        
        ```jsx
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>CryptoZombies front-end</title>
            <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
            <script language="javascript" type="text/javascript" src="web3.min.js"></script>
            <script language="javascript" type="text/javascript" src="cryptozombies_abi.js"></script>
          </head>
          <body>
            <div id="txStatus"></div>
            <div id="zombies"></div>
        
            <script>
              var cryptoZombies;
              var userAccount;
        
              function startApp() {
                var cryptoZombiesAddress = "YOUR_CONTRACT_ADDRESS";
                cryptoZombies = new web3js.eth.Contract(cryptoZombiesABI, cryptoZombiesAddress);
        
                var accountInterval = setInterval(function() {
                  // 계정이 바뀌었는지 확인
                  if (web3.eth.accounts[0] !== userAccount) {
                    userAccount = web3.eth.accounts[0];
                    // 새 계정에 대한 UI로 업데이트하기 위한 함수 호출
                    getZombiesByOwner(userAccount)
                    .then(displayZombies);
                  }
                }, 100);
              }
        
              function displayZombies(ids) {
                $("#zombies").empty();
                for (id of ids) {
                  // 우리 컨트랙트에서 좀비 상세 정보를 찾아, `zombie` 객체 반환
                  getZombieDetails(id)
                  .then(function(zombie) {
                    // HTML에 변수를 넣기 위해 ES6의 "template literal" 사용
                    // 각각을 #zombies div에 붙여넣기
                    $("#zombies").append(`<div class="zombie">
                      <ul>
                        <li>Name: ${zombie.name}</li>
                        <li>DNA: ${zombie.dna}</li>
                        <li>Level: ${zombie.level}</li>
                        <li>Wins: ${zombie.winCount}</li>
                        <li>Losses: ${zombie.lossCount}</li>
                        <li>Ready Time: ${zombie.readyTime}</li>
                      </ul>
                    </div>`);
                  });
                }
              }
        
              function createRandomZombie(name) {
                // 시간이 꽤 걸릴 수 있으니, 트랜잭션이 보내졌다는 것을
                // 유저가 알 수 있도록 UI를 업데이트해야 함
                $("#txStatus").text("Creating new zombie on the blockchain. This may take a while...");
                // 우리 컨트랙트에 전송하기:
                return CryptoZombies.methods.createRandomZombie(name)
                .send({ from: userAccount })
                .on("receipt", function(receipt) {
                  $("#txStatus").text("Successfully created " + name + "!");
                  // 블록체인에 트랜잭션이 반영되었으며, UI를 다시 그려야 함
                  getZombiesByOwner(userAccount).then(displayZombies);
                })
                .on("error", function(error) {
                  // 사용자들에게 트랜잭션이 실패했음을 알려주기 위한 처리
                  $("#txStatus").text(error);
                });
              }
        
              function feedOnKitty(zombieId, kittyId) {
                $("#txStatus").text("Eating a kitty. This may take a while...");
                return CryptoZombies.methods.feedOnKitty(zombieId, kittyId)
                .send({ from: userAccount })
                .on("receipt", function(receipt) {
                  $("#txStatus").text("Ate a kitty and spawned a new Zombie!");
                  getZombiesByOwner(userAccount).then(displayZombies);
                })
                .on("error", function(error) {
                  $("#txStatus").text(error);
                });
              }
        
              function levelUp(zombieId) {
                $("#txStatus").text("좀비를 레벨업하는 중...");
                return CryptoZombies.methods.levelUp(zombieId)
                .send({ from: userAccount, value: web3js.utils.toWei("0.001") })
                .on("receipt", function(receipt) {
                  $("#txStatus").text("압도적인 힘! 좀비가 성공적으로 레벨업했습니다.");
                })
                .on("error", function(error) {
                  $("#txStatus").text(error);
                });
              }
        
              function getZombieDetails(id) {
                return cryptoZombies.methods.zombies(id).call()
              }
        
              function zombieToOwner(id) {
                return cryptoZombies.methods.zombieToOwner(id).call()
              }
        
              function getZombiesByOwner(owner) {
                return cryptoZombies.methods.getZombiesByOwner(owner).call()
              }
        
              window.addEventListener('load', function() {
        
                // Web3가 브라우저에 주입되었는지 확인(Mist/MetaMask)
                if (typeof web3 !== 'undefined') {
                  // Mist/MetaMask의 프로바이더 사용
                  web3js = new Web3(web3.currentProvider);
                } else {
                  // 사용자가 Metamask를 설치하지 않은 경우에 대해 처리
                  // 사용자들에게 Metamask를 설치하라는 등의 메세지를 보여줄 것
                }
        
                // 이제 자네 앱을 시작하고 web3에 자유롭게 접근할 수 있네:
                startApp()
        
              })
            </script>
          </body>
        </html>
        ```
        

### ****이벤트(Event) 구독하기****

컨트랙트에서 이벤트를 구독

- ****새로운 좀비 수신하기****
    - `zombiefactory.sol`을 다시 생각해보면, 새로운 좀비가 생성될 때마다 매번 호출되던 `NewZombie`라는 이벤트가 있었네:
    
    ```solidity
    event NewZombie(uint zombieId, string name, uint dna);
    ```
    
    - Web3.js에서 자네는 이벤트를 **구독하여** 해당 이벤트가 발생할 때마다 Web3 프로바이더가 자네의 코드 내의 어떠한 로직을 실행시키도록 할 수 있네:
    
    ```jsx
    cryptoZombies.events.NewZombie()
    .on("data", function(event) {
      let zombie = event.returnValues;
      // `event.returnValue` 객체에서 이 이벤트의 세 가지 반환 값에 접근할 수 있네:
      console.log("새로운 좀비가 태어났습니다!", zombie.zombieId, zombie.name, zombie.dna);
    }).on("error", console.error);
    ```
    
    - 이건 DApp에서 어떤 좀비가 생성되든지 항상 알림을 보낼 거라는 걸 명심하게 - 현재 사용자의 좀비만이 아니라는 것이네. 현재 사용자가 만든 것에 대해서만 알림을 보내고 싶다면 어떻게 해야 하겠는가?
- ****`indexed` 사용하기**
    - 이벤트를 필터링하고 현재 사용자와 연관된 변경만을 수신하기 위해, 우리의 ERC721을 구현할 때 `Transfer` 이벤트에서 했던 것처럼 우리의 솔리디티 컨트랙트에 `indexed` 키워드를 사용해야 하네.
    
    ```solidity
    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
    ```
    
    - 이 경우, `_from`과 `_to`가 `indexed`되어 있기 때문에, 우리 프론트엔드의 이벤트 리스너에서 이들을 필터링할 수 있네:
    
    ```jsx
    // `filter`를 사용해 `_to`가 `userAccount`와 같을 때만 코드를 실행
    cryptoZombies.events.Transfer({ filter: { _to: userAccount } })
    .on("data", function(event) {
      let data = event.returnValues;
      // 현재 사용자가 방금 좀비를 받았네!
      // 해당 좀비를 보여줄 수 있도록 UI를 업데이트할 수 있도록 여기에 추가
    }).on("error", console.error);
    ```
    
    - 자네도 볼 수 있듯이, `event`와 `indexed` 영역을 사용하는 것은 자네 컨트랙트에서 변화를 감지하고 프론트엔드에 반영할 수 있게 하는 유용한 방법이네.
- ****지난 이벤트에 대해 질의하기****
    - 우린 `getPastEvents`를 이용해 지난 이벤트들에 대해 질의를 하고, `fromBlock`과 `toBlock`필터들을 이용해 이벤트 로그에 대한 시간 범위를 솔리디티에 전달할 수 있네(여기서 "block"은 이더리움 블록 번호를 나타낸다네).
    
    ```jsx
    cryptoZombies.getPastEvents("NewZombie", { fromBlock: 0, toBlock: "latest" })
    .then(function(events) {
      // `events`는 우리가 위에서 했던 것처럼 반복 접근할 `event` 객체들의 배열이네.
      // 이 코드는 생성된 모든 좀비의 목록을 우리가 받을 수 있게 할 것이네.
    });
    ```
    
    위 메소드를 사용해서 시작 시간부터의 이벤트 로그들에 대해 질의를 할 수 있기 때문에, 이를 통해 흥미로운 사용 예시를 만들 수 있네: **이벤트를 저렴한 형태의 storage로 사용하는 것이네**.
    
    다시 생각해보면, 데이터를 블록체인에 기록하는 것은 솔리디티에서 가장 비싼 비용을 지불하는 작업 중 하나였네. 하지만 이벤트를 이용하는 것은 가스 측면에서 훨씬 더 저렴하네.
    
    여기서 단점이 되는 부분은 스마트 컨트랙트 자체 안에서는 이벤트를 읽을 수 없다는 것이네. 하지만 히스토리로 블록체인에 기록하여 앱의 프론트엔드에서 읽기를 원하는 데이터가 있다면, 이는 새겨놓아야 할 중요한 사용 예시이네.
    
    예를 들어, 우린 이것을 좀비 전투의 히스토리 기록용으로 사용할 수 있네 - 좀비가 다른 좀비를 공격할 때마다, 그리고 누군가 이길 때마다 우린 이벤트를 생성할 수 있네. 스마트 컨트랙트는 추후 결과를 계산할 때 이 데이터가 필요하지 않지만, 사용자들이 앱의 프론트엔드에서 찾아볼 수 있는 유용한 데이터이지.
    
- 예제 ) `Transfer` 이벤트를 감지할 수 있는 코드를 추가해보도록 하지. 그리고 현재 사용자가 새로운 좀비를 받았을 떄 우리 앱의 UI를 업데이트하도록 하겠네. 우린 이 코드를 `startApp`코드의 끝부분에 추가해야 하네. 이벤트 리스너를 추가하기 전에 `cryptoZombies` 컨트랙트가 확실히 초기화될 수 있도록 하기 위해서이지.
    1. `startApp()`의 끝부분에 `crpytoZombies.events.Transfer`를 수신하는 위의 코드 블록을 복사/붙여넣기 하게.
    2. UI를 업데이트 해야 하는 부분에 `getZombiesByOwner(userAccount).then(displayZombies);`를 사용하게. 
    - 예제 코드
        
        ```jsx
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>CryptoZombies front-end</title>
            <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
            <script language="javascript" type="text/javascript" src="web3.min.js"></script>
            <script language="javascript" type="text/javascript" src="cryptozombies_abi.js"></script>
          </head>
          <body>
            <div id="txStatus"></div>
            <div id="zombies"></div>
        
            <script>
              var cryptoZombies;
              var userAccount;
        
              function startApp() {
                var cryptoZombiesAddress = "YOUR_CONTRACT_ADDRESS";
                cryptoZombies = new web3js.eth.Contract(cryptoZombiesABI, cryptoZombiesAddress);
        
                var accountInterval = setInterval(function() {
                  // 계정이 바뀌었는지 확인
                  if (web3.eth.accounts[0] !== userAccount) {
                    userAccount = web3.eth.accounts[0];
                    // 새 계정에 대한 UI로 업데이트하기 위한 함수 호출
                    getZombiesByOwner(userAccount)
                    .then(displayZombies);
                  }
                }, 100);
        
                // 여기서 시작하게.
                cryptoZombies.events.Transfer({ filter: { _to: userAccount } })
                .on("data", function(event) {
                  let data = event.returnValues;
                  getZombiesByOwner(userAccount).then(displayZombies);
                }).on("error", console.error);
              }
        
              function displayZombies(ids) {
                $("#zombies").empty();
                for (id of ids) {
                  // 우리 컨트랙트에서 좀비 상세 정보를 찾아, `zombie` 객체 반환
                  getZombieDetails(id)
                  .then(function(zombie) {
                    // HTML에 변수를 넣기 위해 ES6의 "template literal" 사용
                    // 각각을 #zombies div에 붙여넣기
                    $("#zombies").append(`<div class="zombie">
                      <ul>
                        <li>Name: ${zombie.name}</li>
                        <li>DNA: ${zombie.dna}</li>
                        <li>Level: ${zombie.level}</li>
                        <li>Wins: ${zombie.winCount}</li>
                        <li>Losses: ${zombie.lossCount}</li>
                        <li>Ready Time: ${zombie.readyTime}</li>
                      </ul>
                    </div>`);
                  });
                }
              }
        
              function createRandomZombie(name) {
                // 시간이 꽤 걸릴 수 있으니, 트랜잭션이 보내졌다는 것을
                // 유저가 알 수 있도록 UI를 업데이트해야 함
                $("#txStatus").text("Creating new zombie on the blockchain. This may take a while...");
                // 우리 컨트랙트에 전송하기:
                return CryptoZombies.methods.createRandomZombie(name)
                .send({ from: userAccount })
                .on("receipt", function(receipt) {
                  $("#txStatus").text("Successfully created " + name + "!");
                  // 블록체인에 트랜잭션이 반영되었으며, UI를 다시 그려야 함
                  getZombiesByOwner(userAccount).then(displayZombies);
                })
                .on("error", function(error) {
                  // 사용자들에게 트랜잭션이 실패했음을 알려주기 위한 처리
                  $("#txStatus").text(error);
                });
              }
        
              function feedOnKitty(zombieId, kittyId) {
                $("#txStatus").text("Eating a kitty. This may take a while...");
                return CryptoZombies.methods.feedOnKitty(zombieId, kittyId)
                .send({ from: userAccount })
                .on("receipt", function(receipt) {
                  $("#txStatus").text("Ate a kitty and spawned a new Zombie!");
                  getZombiesByOwner(userAccount).then(displayZombies);
                })
                .on("error", function(error) {
                  $("#txStatus").text(error);
                });
              }
        
              function levelUp(zombieId) {
                $("#txStatus").text("좀비를 레벨업하는 중...");
                return CryptoZombies.methods.levelUp(zombieId)
                .send({ from: userAccount, value: web3.utils.toWei("0.001") })
                .on("receipt", function(receipt) {
                  $("#txStatus").text("압도적인 힘! 좀비가 성공적으로 레벨업했습니다.");
                })
                .on("error", function(error) {
                  $("#txStatus").text(error);
                });
              }
        
              function getZombieDetails(id) {
                return cryptoZombies.methods.zombies(id).call()
              }
        
              function zombieToOwner(id) {
                return cryptoZombies.methods.zombieToOwner(id).call()
              }
        
              function getZombiesByOwner(owner) {
                return cryptoZombies.methods.getZombiesByOwner(owner).call()
              }
        
              window.addEventListener('load', function() {
        
                // Web3가 브라우저에 주입되었는지 확인(Mist/MetaMask)
                if (typeof web3 !== 'undefined') {
                  // Mist/MetaMask의 프로바이더 사용
                  web3js = new Web3(web3.currentProvider);
                } else {
                  // 사용자가 Metamask를 설치하지 않은 경우에 대해 처리
                  // 사용자들에게 Metamask를 설치하라는 등의 메세지를 보여줄 것
                }
        
                // 이제 자네 앱을 시작하고 web3에 자유롭게 접근할 수 있네:
                startApp()
        
              })
            </script>
          </body>
        </html>
        ```
        

### ****마무리하기****

- ****다음 단계****

이번 레슨은 일부러 기초적인 것을 다뤘네. 우리는 자네에게 스마트 컨트랙트와 상호작용 할 때 필요한 핵심 로직을 보여주고 싶었네. 하지만 코드에서 Web3.js 부분은 꽤 반복적인 게 많기 때문에 전체 구현을 하는 데에 너무 많은 시간을 쓰고 싶지는 않았네. 이번 레슨을 더 길게 만들어 다른 새로운 개념을 소개하지도 않을 것이네.

그러니 이런 구현은 기초적인 것으로 놔두고, 우리 좀비 게임 프론트엔드의 완전한 구현을 위해 생각해볼 것들의 체크리스트를 알려주겠네. 자네가 이걸 자네만의 것으로 만들어보고 싶다면:

1. `attack`, `changeName`, `changeDna`, 그리고 ERC721 함수인 `transfer`, `ownerOf`, `balanceOf` 함수를 구현하게. 이런 함수들의 구현은 우리가 다룬 모든 다른 `send` 트랜잭션과 동일할 것이네.
2. 자네가 `setKittyContractAddress`, `setLevelUpFee`, 그리고 `withdraw`를 실행할 수 있는 "관리 페이지"를 구현하게. 다시 한번 말하지만, 프론트엔드에 더 특별한 로직은 없네 - 이러한 구현들은 우리가 이미 다룬 함수들과 동일할 것이네. 자네는 그저 해당 컨트랙트를 배포했던 이더리움 주소에서 이 함수들을 호출했는지 확인하면 되네. 이 함수들은 `onlyOwner` 제어자를 가지고 있으니 말이야.
3. 이 앱에서 구현하고 싶은 다른 몇 가지 화면이 있을 수 있네:
    
    a. 개별 좀비 페이지: 특정 좀비에 대한 영구적인 링크를 통해 그 좀비의 정보를 볼 수 있는 곳이지. 이 페이지에서는 좀비의 외관과 이름, 주인(사용자 프로필 페이지에 대한 링크와 함께), 승리/패배 횟수, 전투 기록, 기타 등등을 보여줄 것이네.
    
    b. 사용자 페이지: 영구적인 링크를 통해 사용자의 좀비 군대를 볼 수 있는 곳이지. 개별 좀비를 클릭하여 해당 페이지를 볼 수 있을 것이고, 자네가 메타마스크에 로그인되어 있고, 군대를 가지고 있다면 좀비를 클릭해 공격할 수도 있을 것이네.
    
    c. 홈페이지: 현재 사용자의 좀비 군대를 볼 수 있는, 사용자 페이지의 한 종류이지(우리가 index.html에서 구현학 시작헀던 곳이네).
    
4. UI 상에서 사용자가 크립토키티를 먹이로 줄 수 있는 방법이 있어야 하겠지. 홈페이지에서 각 좀비 옆에 "먹이 주기" 같은 버튼을 만들고, 사용자가 고양이의 ID를 입력하게 하는 텍스트 박스를 만들 수 있겠지(또는 그 고양이의 URL, 예를 들면: [https://www.cryptokitties.co/kitty/578397](https://www.cryptokitties.co/kitty/578397)). 이 버튼은 `feedOnKitty` 함수를 호출할 것이네.
5. UI 상에서 한 사용자가 다른 사용자의 좀비를 공격할 수 있는 방법이 있어야 할 것이네.
    
    이를 구현하는 하나의 방법은 한 사용자가 다른 사용자의 페이지로 들어가면, "이 좀비 공격하기" 버튼을 보여주는 것이네. 사용자가 그 버튼을 클릭하면, 현재 사용자의 좀비 군대를 포함하는 모달 창을 띄우고 "어떤 좀비로 공격하시겠습니까?" 메세지를 보여주면 되네.
    
    또 사용자의 홈페이지에서 각 좀비 옆에 "좀비 공격하기" 버튼을 둘 수도 있네. 사용자가 그걸 클릭하면, 사용자가 좀비의 ID를 입력하여 찾을 수 있는 찾기 영역을 가지는 모달 창을 띄울 수 있겠지. 또는 "아무 좀비나 공격하기" 같은 옵션을 줘서 임의로 찾을 수도 있을 것이네.
    
    그리고 쿨다운 기간이 아직 다 지나지 않은 사용자의 좀비는 회색 처리를 할 수도 있겠지. UI 상에서 사용자에게 해당 좀비로는 아직 공격할 수 없고 얼마나 더 기다려야 하는지 보여줄 수 있도록 말이야.
    
6. 사용자의 홈페이지에는 각 좀비의 이름 또는 DNA를 바꾸고, 일정 비용을 내고 레벨업을 할 수 있는 옵션이 있을 수 있네. 사용자의 레벨이 충분하지 않으면 어떤 옵션들을 회색 처리를 할 수 있곘지.
7. 새로운 사용자들을 위해, `createRandomZombie()`를 호출해 군대의 첫 번째 좀비를 만들 수 있는 입력 창과 함께 환영 메세지를 보여줄 수 있네.
8. 마지막 챕터에서 논의한 것처럼, 우리 스마트 컨트랙트에 `indexed` 프로퍼티로 사용자의 `address`를 가지는 `Attack` 이벤트를 추가하고 싶을 수 있네. 이를 통해 실시간 알림을 만들 수 있을 것이네 - 사용자에게 그의 좀비가 공격당하면 알림 창을 띄워 알려주어, 그를 공격한 사용자/좀비를 보여주고 복수할 수 있게 하는 것이지.
9. 또한 일종의 프론트엔드 캐시 계층을 구현하여 똑같은 데이터를 위해 Infura에 계속 접근하지는 않도록 하고 싶을 수 있네(우리의 현재 `displayZombies` 구현은 인터페이스를 새로고침할 때마다 각 좀비에 대해 `getZombieDetails`를 호출하지 - 하지만 현실적으로 우리의 군대에 추가된 새 좀비에 대해서만 이 함수를 호출하면 되네).
10. 실시간 채팅방을 만들어 자네가 다른 사용자들의 군대를 부술 때마다 그 사용자를 도발할 수 있도록 하는 것? 제발 만들어 주게...

이건 시작일 뿐이네 - 우리는 더 많은 기능들을 생각해낼 수 있을 것이야 - 그리고 이미 많은 목록을 만들었지.

이런 전체 인터페이스를 만드는 데에는 많은 프론트엔드 코드를 써야 할 것이기에(HTML, CSS, 자바스크립트, 그리고 React나 Vue.js 같은 프레임워크), 이런 전체 프론트엔드를 만드는 것은 이것만으로 10개 레슨으로 전체 코스를 만들어야 할 것이야. 그러니 이 엄청난 구현은 자네에게 맡기겠네.

> 참고: 우리 스마트 컨트랙트는 분산화되어 있지만, 우리 DApp과 상호작용 할 수 있는 이 프론트엔드는 어딘가의 웹 서버에 완전히 중앙화되어 있을 것이네.하지만, 우리가 Loom Network에서 만들고 있는 SDK를 쓰면, 중앙화된 웹 서버 대신 곧 자신만의 DAppChain에서 프론트엔드를 제공할 수 있을 것이네. 이더리움과 Loom DAppChain 간의 저런 방식으로, 전체 앱이 100% 블록체인 상에서 돌아갈 것이네.
> 

## **결론**

이것으로 레슨 6이 끝났네. 이제 자네는 스마트 컨트랙트를 작성하고 사용자가 이와 통신할 수 있게 하는 프론트엔드를 만드는 모든 기술을 배웠네!

다음 레슨에서는, 이 퍼즐에서 마지막 잃어버린 조각을 다룰 것이네 - 스마트 컨트랙트를 이더리움에 배포하는 것이지.

"다음 챕터"를 클릭하여 보상을 받도록 하게!