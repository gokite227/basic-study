# 3.고급 솔리디티 개념

---

---

### 컨트랙트의 불변성

- 첫째로, 자네가 이더리움에 컨트랙트를 배포하고 나면, 컨트랙트는 변하지 않는다**(Immutable).**
- 컨트랙트를 수정하거나 업데이트할 수 없다는 것
- 컨트랙트로 배포한 최초의 코드는 항상, 블록체인에 영구적으로 존재.
    - 솔리디티에 있어서 보안이 괸장히 큰 이슈인 이유
- 컨트랙트 코드에 결점이 있어도 고칠 수 없음
    - 사용자들에게 결점을 보완한 다른 스마트 컨트랙트 주소를 써야 함.

### 외부 의존성

- 외부 컨트랙트의 주소를 DApp에 직접 넣었을 경우:
    - 만약 외부 컨트랙트에 버그가 있었고, 누군가 모든 것을 파괴했을 경우 DApp는 쓸모 없어짐
    - 컨트랙트의 불변성으로 컨트랙트를 수정할 수도 없음
- DApp의 중요한 일부를 수정할 수 있도록 하는 함수 생성
    - ex) 우리 DApp에 크립토키티 컨트랙트 주소를 직접 써넣는 것 대신, 
    언젠가 크립토키티 컨트랙트에 문제가 생기면 해당 주소를 바꿀 수 있도록 
    해주는 `setKittyContractAddres`함수를 생성
- 예제) 크립토키티 컨트랙트 주소의 업데이트가 가능하도록 바꾸기.
    1. 우리가 직접 주소를 써넣었던 `ckAddress`가 있는 줄을 지우게.
    2. 우리가 `kittyContract`를 생성했던 줄을 변수 선언만 하도록 변경하게 - 어떤 것도 대입을 하지 않도록 하게.
    3. `setKittyContractAddress`라는 이름의 함수를 생성하게. 이 함수는 `address` 타입의 변수 `_address`를 하나의 인자로 받고, `external` 함수여야 하네.
    4. 함수 내에서, `kittyContract`에 `KittyInterface(_address)`를 대입하는 한 줄의 코드를 작성하게.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefactory.sol";
        
        contract KittyInterface {
          function getKitty(uint256 _id) external view returns (
            bool isGestating,
            bool isReady,
            uint256 cooldownIndex,
            uint256 nextActionAt,
            uint256 siringWithId,
            uint256 birthTime,
            uint256 matronId,
            uint256 sireId,
            uint256 generation,
            uint256 genes
          );
        }
        
        contract ZombieFeeding is ZombieFactory {
          
          
          KittyInterface kittyContract;
        
          function setKittyContractAddress(address _address) external{
            kittyContract = KittyInterface(_address);
          }
        
          function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public {
            require(msg.sender == zombieToOwner[_zombieId]);
            Zombie storage myZombie = zombies[_zombieId];
            _targetDna = _targetDna % dnaModulus;
            uint newDna = (myZombie.dna + _targetDna) / 2;
            if (keccak256(_species) == keccak256("kitty")) {
              newDna = newDna - newDna % 100 + 99;
            }
            _createZombie("NoName", newDna);
          }
        
          function feedOnKitty(uint _zombieId, uint _kittyId) public {
            uint kittyDna;
            (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
            feedAndMultiply(_zombieId, kittyDna, "kitty");
          }
        
        }
        ```
        

### 소유 가능한 컨트랙트

<aside>
📎 이전 챕터의 취약점 :  `setKittyContractAddress`함수는 `external`이라, 누구든 이 함수를 호출할 수 있음. 이는 아무나 이 함수를 호출해서 크립트키티 컨트랙트의 주소를 바꿀 수 있고, 모든 사용자를 대상으로 우리 앱을 무용지물로 만들 수 있다는 것.
컨트랙트에서 이 주소를 바꿀 수 있게끔 하고 싶지만, 그렇다고 모든 사람이 주소를 업데이트할 수 있기를 원하지는 않음.

방법은 컨트랙트를 `소유 가능`하게 만드는 것. 컨트랙트를 대상으로 특별한 권리를 가지는 소유자가 있음을 의미.

</aside>

- ****OpenZeppelin의 `Ownable` 컨트랙트**
    - OpenZeppelin은 DApp에서 사용할 수 있는, 안전하고 커뮤니티에서 검증받은 스마트 컨트랙트의 라이브러리
    - 예시 코드) ***OpenZeppelin***솔리디티 라이브러리에서 가져온 `Ownable`컨트랙트
        
        ```solidity
        /**
         * @title Ownable
         * @dev The Ownable contract has an owner address, and provides basic authorization control
         * functions, this simplifies the implementation of "user permissions".
         */
        contract Ownable {
          address public owner;
          event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
        
          /**
           * @dev The Ownable constructor sets the original `owner` of the contract to the sender
           * account.
           */
          function Ownable() public {
            owner = msg.sender;
          }
        
          /**
           * @dev Throws if called by any account other than the owner.
           */
          modifier onlyOwner() {
            require(msg.sender == owner);
            _;
          }
        
          /**
           * @dev Allows the current owner to transfer control of the contract to a newOwner.
           * @param newOwner The address to transfer ownership to.
           */
          function transferOwnership(address newOwner) public onlyOwner {
            require(newOwner != address(0));
            OwnershipTransferred(owner, newOwner);
            owner = newOwner;
          }
        }
        ```
        
    - 생성자(Constructor): `function Ownable()`는 ***생성자***. 컨트랙트와 동일한 이름을 가진,생략할 수 있는 특별한 함수. 이 함수는 컨트랙트가 생성될 때 딱 한 번만 실행.
    - 함수 제어자(Function Modifier): `modifier onlyOwner()`. 제어자는 다른 함수들에 대한 접근을 제어하기 위해 사용되는 일종의 유사 함수. 보통 함수 실행 전의 요구사항 충족 여부를 확인하는 데에 사용. `onlyOwner`의 경우에는 접근을 제한해서 **오직** 컨트랙트의 **소유자**만 해당 함수를 실행할 수 있도록 하기 위해 사용. 우리는 다음 챕터에서 함수 제어자에 대해 더 살펴보고, `_;`라는 것이 뭘 하는 것인지 알아볼 것.
    - `Ownable` 컨트랙트는 기본적으로 다음과 같은 것들을 한다:
        1. 컨트랙트가 생성되면 컨트랙트의 생성자가 `owner`에 `msg.sender`(컨트랙트를 배포한 사람)를 대입한다.
        2. 특정한 함수들에 대해서 오직 `소유자`만 접근할 수 있도록 제한 가능한 `onlyOwner` 제어자를 추가한다.
        3. 새로운 `소유자`에게 해당 컨트랙트의 소유권을 옮길 수 있도록 한다.
    - `onlyOwner`는 컨트랙트에서 흔히 쓰는 것 중 하나, 대부분의 솔리디티 DApp들은 `Ownable`
     컨트랙트를 복사/붙여넣기 하면서 시작. 첫 컨트랙트는 이 컨트랙트를 상속해서 만듬.
    
- 예제) 먼저 `Ownable`컨트랙트의 코드를 `ownable.sol`이라는 새로운 파일로 복사함. `ZombieFactory`가 이걸 상속 받게 하기.
    1. 우리 코드가 `ownable.sol`의 내용을 `import`하도록 수정하게. 어떻게 하는지 기억이 나지 않는다면 `zombiefeeding.sol`을 살펴보게.
    2. `ZombieFactory` 컨트랙트가 `Ownable`을 상속하도록 수정하게. 다시 말하지만, 이걸 어떻게 하는지 잘 기억나지 않는다면 `zombiefeeding.sol`을 살펴보게.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./ownable.sol";
        
        contract ZombieFactory is Ownable {
        
            event NewZombie(uint zombieId, string name, uint dna);
        
            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;
        
            struct Zombie {
                string name;
                uint dna;
            }
        
            Zombie[] public zombies;
        
            mapping (uint => address) public zombieToOwner;
            mapping (address => uint) ownerZombieCount;
        
            function _createZombie(string _name, uint _dna) internal {
                uint id = zombies.push(Zombie(_name, _dna)) - 1;
                zombieToOwner[id] = msg.sender;
                ownerZombieCount[msg.sender]++;
                NewZombie(id, _name, _dna);
            }
        
            function _generateRandomDna(string _str) private view returns (uint) {
                uint rand = uint(keccak256(_str));
                return rand % dnaModulus;
            }
        
            function createRandomZombie(string _name) public {
                require(ownerZombieCount[msg.sender] == 0);
                uint randDna = _generateRandomDna(_name);
                randDna = randDna - randDna % 100;
                _createZombie(_name, randDna);
            }
        
        }
        ```
        

### ****onlyOwner 함수 제어자****

- 함수 제어자
    - 함수 제어자는 함수처럼 보이지만, `function` 키워드 대신 `modifier` 키워드를 사용
    - 함수를 호출하듯이 호출 할 수 없음.
    - 대신 함수 정의부 끝에 해당 함수의 작동 방식을 바꾸도록 제어자의 이름을 붙일 수 있음
        
        ```solidity
        /**
         * @dev Throws if called by any account other than the owner.
         */
        modifier onlyOwner() {
          require(msg.sender == owner);
          _;
        }
        ```
        
        ```solidity
        contract MyContract is Ownable {
          event LaughManiacally(string laughter);
        
          // 아래 `onlyOwner`의 사용 방법을 잘 보게:
          function likeABoss() external onlyOwner {
            LaughManiacally("Muahahahaha");
          }
        }
        ```
        
    - `likeABoss`함수의 `onlyOwner`제어자 부분에,  `likeABoss` 함수를 호출하면, `onlyOwner`의 코드가 **먼저** 실행된다. 그리고 `onlyOwner`의 `_;` 부분을 `likeABoss`함수로 되돌아가 해당 코드를 실행하게 된다.
    - 제어자를 사용할 수 있는 다양한 방법이 있지만, 가장 일반적으로 쓰는 예시 중 하나는 함수 실행 전에 `require`체크를 넣는 것.
    - `onlyOwner`의 경우에는, 함수에 이 제어자를 추가하면 **오직** 컨트랙트의 **소유자**만이 해당 함수를 호출할 수 있다.
    
    > 참고: 이렇게 소유자가 컨트랙트에 특별한 권한을 갖도록 하는 것은 자주 필요하지만, 이게 악용될 수도 있음. 예를 들어, 소유자가 다른 사람의 좀비를 뺏어올 수 있도록 하는 백도어 함수를 추가 할 수도 있음.
    > 
    
    > 이더리움에서 돌아가는 DApp이라고 해서 그것만으로 분산화되어 있다고 할 수는 없음. 반드시 전체 소스 코드를 읽어보고, 잠재적으로 걱정할 만한, 소유자에 의한 특별한 제어가 불가능한 상태인지 확인. 개발자로서는 잠재적인 버그를 수정하고 DApp을 안정적으로 유지하도록 하는 것과, 사용자들이 그들의 데이터를 믿고 저장할 수 있는 소유자가 없는 플랫폼을 만드는 것 사이에서 균형을 잘 잡는 것이 중요.
    > 
- 예제) 미래에 `setKittyContractAddress`를 우리만 수정할 수 있도록 제한
    
    1. `onlyOwner` 제어자를 `setKittyContractAddress`에 추가.
    
    - 예제 코드)
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefactory.sol";
        
        contract KittyInterface {
          function getKitty(uint256 _id) external view returns (
            bool isGestating,
            bool isReady,
            uint256 cooldownIndex,
            uint256 nextActionAt,
            uint256 siringWithId,
            uint256 birthTime,
            uint256 matronId,
            uint256 sireId,
            uint256 generation,
            uint256 genes
          );
        }
        
        contract ZombieFeeding is ZombieFactory {
        
          KittyInterface kittyContract;
        
          // 이 함수를 수정:
          function setKittyContractAddress(address _address) external onlyOwner {
            kittyContract = KittyInterface(_address);
          }
        
          function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public {
            require(msg.sender == zombieToOwner[_zombieId]);
            Zombie storage myZombie = zombies[_zombieId];
            _targetDna = _targetDna % dnaModulus;
            uint newDna = (myZombie.dna + _targetDna) / 2;
            if (keccak256(_species) == keccak256("kitty")) {
              newDna = newDna - newDna % 100 + 99;
            }
            _createZombie("NoName", newDna);
          }
        
          function feedOnKitty(uint _zombieId, uint _kittyId) public {
            uint kittyDna;
            (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
            feedAndMultiply(_zombieId, kittyDna, "kitty");
          }
        
        }
        ```
        
    

### 가스(Gas)

- **가스 : 이더리움 DApp이 사용하는 연료**
    - 솔리디티에서 사용자들은 DApp의 함수를 실행할 때마다 ***가스***라고 불리는 화폐를 지불.
    - 사용자는 이더(ETH,이더리움의 화폐)를 이용해서 가스를 사기 때문에, DApp함수를 실행 하려면 사용자들은 ETH를 소모해야함.
    - 함수 실행시 얼마나 많은 가스가 필요한지는 함수의 로직(논리구조)이 얼마나 복잡한지에 따라 달라짐
    - 각각의 연산은  ***가스 비용(gas cost)***이 있고, 그 연산을 수행하는 데에 소모되는 컴퓨팅 자원의 양이 이 비용을 결정
        - ex) storage에 값을 쓰는 것은 두 개의 정수를 더하는 것보다 훨씬 비용이 높다.
        - ex)함수의 전체 ***가스 비용***은 그 함수를 구성하는 개별 연산들의 가스 비용을 모두 합친 것과 같다.
    - 함수를 실행하는 것은 사용자들에게 실제 돈을 쓰게 하기 때문에, 이더리움에서 코드 최적화는 다른 프로그래밍 언어들에 비해 훨씬 중요.
    - 코드가 엉망이면, 사용자들은 함수를 실행하기 위해 일종의 할증료를 더 내야함. 이용자가 수천 명이라면 할증료가 수십 억원까지 쌓일 수 있음
- **가스는 왜 필요한가?**
    - 이더리움은 크고 느림, 하지만 굉장히 안전한 컴퓨터 같음
    - 어떠한 함수를 실행 시, 네트워크상의 모든 개별 노드가 함수의 출력값을 검증하기 위해 그 함수를 실행. 
    모든 함수의 실행 검증하는 수천 개의 노드가 바로 이더리움을 분산화하고, 데이터를 보존하며 누군가 검열할 수 없도록 하는 요소
        
        > 참고: 사이드체인에서는 반드시 이렇지는 않음. 크립토좀비를 만든 사람들이 Loom Network에서 만들고 있는 것들이 좋은 예시. 이더리움 메인넷에서 월드 오브 워크래프트 같은 게임을 직접적으로 돌리는 것은 절대 말이 되지 않음. 가스 비용이 엄청나게 높을 것이기 때문. 하지만 다른 합의 알고리즘을 가진 사이드체인에서는 가능할 수 있음. 다음에 나올 레슨에서 DApp을 사이드체인에 올릴지, 이더리움 메인넷에 올릴지 판단하는 방법들에 대해 더 탐구.
        > 
- **가스를 아끼기 위한 구조체 압축**
    - 솔리디티에서는 `uint`의 크기에 상관없이 256비트의 저장 공간을 미리 잡아놓기 때문에 하위 타입을 쓰는 것은 가스 소모를 줄이는데 아무런 영향 없음
    - 그러나,  `struct`의 안에서는 가능한 더 작은 크기의 `uint`를 써야함. 솔리디티에서 그 변수들을 더 적은 공간을 차지하도록 압축하기 때문.
        
        ```solidity
        struct NormalStruct {
          uint a;
          uint b;
          uint c;
        }
        
        struct MiniMe {
          uint32 a;
          uint32 b;
          uint c;
        }
        
        // `mini`는 구조체 압축을 했기 때문에 `normal`보다 가스를 조금 사용할 것이네.
        NormalStruct normal = NormalStruct(10, 20, 30);
        MiniMe mini = MiniMe(10, 20, 30);
        ```
        
    - 구조체 안에서는 가능한 작은 크기의 정수타입 사용, 동일한 데이터 타입은 하나로 묶음
        - ex)`uint c; uint32 a; uint32 b;`라는 필드로 구성된 구조체가 
             `uint32 a; uint c; uint32 b;`필드로 구성된 구조체보다 가스를 덜 소모함. 
             `uint32`필드가 묶여있기 때문.
- 예제 ) 좀비에게 2개의 새로운 특징을 추가할 것이네. `level`과 `readyTime`. `readyTime`
은 좀비가 먹이를 먹는 빈도를 제한할 재사용 대기 시간을 구현하기 위해 사용.
    
    1. 우리의 `Zombie` 구조체에 2개의 속성을 더 추가: `level`(`uint32`)과 `readyTime`( `uint32`). 이 데이터 타입들을 압축하길 원하니, 이 둘을 구조체의 마지막 부분에 작성.
    
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./ownable.sol";
        
        contract ZombieFactory is Ownable {
        
            event NewZombie(uint zombieId, string name, uint dna);
        
            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;
        
            struct Zombie {
                string name;
                uint dna;
                // 여기 새 데이터를 입력하게
                uint32 level;
                uint32 readyTime;
            }
        
            Zombie[] public zombies;
        
            mapping (uint => address) public zombieToOwner;
            mapping (address => uint) ownerZombieCount;
        
            function _createZombie(string _name, uint _dna) internal {
                uint id = zombies.push(Zombie(_name, _dna)) - 1;
                zombieToOwner[id] = msg.sender;
                ownerZombieCount[msg.sender]++;
                NewZombie(id, _name, _dna);
            }
        
            function _generateRandomDna(string _str) private view returns (uint) {
                uint rand = uint(keccak256(_str));
                return rand % dnaModulus;
            }
        
            function createRandomZombie(string _name) public {
                require(ownerZombieCount[msg.sender] == 0);
                uint randDna = _generateRandomDna(_name);
                randDna = randDna - randDna % 100;
                _createZombie(_name, randDna);
            }
        
        }
        ```
        

### 시간 단위

<aside>
📎 좀비가 먹이를 먹거나 공격을 하고 나서 다시 먹거나 공격할 수 있을 때까지 기다려야 하는 "재사용 대기 시간"을 추가. 좀비가 다시 공격할 때까지 기다려야 하는 시간을 측정하기 위해, 우리는 솔리디티의 시간 단위(Time units)를 사용할 것.

</aside>

- 시간 단위(Time uints)
    - 솔리디티는 시간을 다룰 수 있는 단위계를 기본적으로 제공.
    - `now`변수를 쓰면 현재의 유닉스 타임 스탬프 값을 얻을 수 있음.
    
    > 참고: 유닉스 타임은 전통적으로 32비트 숫자로 저장. 이는 유닉스 타임스탬프 값이 32비트로 표시가 되지 않을 만큼 커졌을 때 많은 구형 시스템에 문제가 발생할 "Year 2038" 문제를 일으킬 것. 그러니 만약 우리 DApp이 지금부터 20년 이상 운영되길 원한다면, 우리는 64비트 숫자를 써야 할 것. 하지만 우리 유저들은 그동안 더 많은 가스를 소모해야 함.
    > 
    - 솔리디티는 `seconds`, `minutes`, `hours`, `days`, `weeks`, `years`같은 시간 단위 또한 포함.
    이들은 그에 해당하는 길이 만큼의 초 단위 uint숫자로 변환
        - ex) `1 minutes`는 `60`, `1 hours`는 `3600`(60초 x 60 분), `1 days`는 `86400`(24시간 x 60분 x 60초) 같이 변환.
        - 시간 단위들은 좀비의 `cooldown`기능을 추가할 때 사용
        
        ```solidity
        uint lastUpdated;
        
        // `lastUpdated`를 `now`로 설정
        function updateTimestamp() public {
          lastUpdated = now;
        }
        
        // 마지막으로 `updateTimestamp`가 호출된 뒤 5분이 지났으면 `true`를, 5분이 아직 지나지 않았으면 `false`를 반환
        function fiveMinutesHavePassed() public view returns (bool) {
          return (now >= (lastUpdated + 5 minutes));
        }
        ```
        
- 예제) DApp에 재사용 대기 시간을 추가하고, 좀비들이 공격하거나 먹이를 먹은 후 **1일**
이 지나야만 다시 공격할 수 있도록 할 것
    1. `cooldownTime`이라는 `uint` 변수를 선언하고, 여기에 `1 days`를 대입하게.(문법적으로 이상하게 보여도 넘어가게. 자네가 "1 day"를 대입한다면, 컴파일이 되지 않을 것일세!)
    2. 우리가 이전 챕터에서 우리의 `Zombie` 구조체에 `level`과 `readyTime`을 추가했으니, 우린 `Zombie` 구조체를 생성할 때 함수의 인수 개수가 정확히 맞도록 `_createZombie()` 함수를 업데이트해야 하네.
        
        코드의 `zombies.push` 줄에 2개의 인수를 더 사용하도록 업데이트하게: `1`(`level`에 사용), `uint32(now + cooldownTime)`(`readyTime`에 사용).
        
    
    > *참고: `now`가 기본적으로 `uint256`을 반환하기 때문에, `uint32(...)` 부분이 필수적. 이렇게 함으로써 해당 데이터를 `uint32`로 명시적으로 변환하는 것.*
    > 
    - `now + cooldownTime`은 현재 유닉스 타임스탬프(초 단위)에 1일을 초 단위로 바꾼 것의 합과 같음. 바꿔 말해 지금부터 하루 뒤의 유닉스 타임스탬프 값과 같은 것. 이후에 우리는 좀비를 다시 사용하기 위해 충분한 시간이 지났는지 확인할 수 있도록 좀비의 `readyTime`이 `now`보다 큰지 비교할 것.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./ownable.sol";
        
        contract ZombieFactory is Ownable {
        
            event NewZombie(uint zombieId, string name, uint dna);
        
            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;
            // 1. `cooldownTime`을 여기에 정의하게
            uint cooldownTime = 1 days;
        
            struct Zombie {
                string name;
                uint dna;
                uint32 level;
                uint32 readyTime;
            }
        
            Zombie[] public zombies;
        
            mapping (uint => address) public zombieToOwner;
            mapping (address => uint) ownerZombieCount;
        
            function _createZombie(string _name, uint _dna) internal {
                // 2. 아래 줄을 업데이트하게:
                uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime))) - 1;
                zombieToOwner[id] = msg.sender;
                ownerZombieCount[msg.sender]++;
                NewZombie(id, _name, _dna);
            }
        
            function _generateRandomDna(string _str) private view returns (uint) {
                uint rand = uint(keccak256(_str));
                return rand % dnaModulus;
            }
        
            function createRandomZombie(string _name) public {
                require(ownerZombieCount[msg.sender] == 0);
                uint randDna = _generateRandomDna(_name);
                randDna = randDna - randDna % 100;
                _createZombie(_name, randDna);
            }
        
        }
        ```
        

### 좀비 재사용 대기시간

- 구조체를 인수로 전달하기
    - `private`또는 `internal`함수에 인수로서 구조체의 storage 포인터를 전달할 수 있음.
    - 예를 들어 함수들 간에 우리의 `Zombie`구조체를 주고받을 때 유용.
    - 함수에 좀비 ID를 전달하고 좀비를 찾는 대신, 우리의 좀비에 대한 참조를 전달할 수 있음.
    
    ```solidity
    function _doStuff(Zombie storage _zombie) internal {
      // _zombie로 할 수 있는 것들을 처리
    }
    ```
    
- 예제) 재사용 대기 시간 타이머를 구현
    
    먹이를 먹으면 좀비가 재사용 대기에 들어가고, 좀비는 재사용 대기 시간이 지날 때까지 고양이들을 먹을 수 없음.
    
    1. `_triggerCooldown`을 정의하면서 시작하지. 이 함수는 1개의 인수로 `Zombie storage` 포인터 타입인 `_zombie`를 받네. 이 함수는 `internal`이어야 하네.
    2. 함수의 내용에서는 `_zombie.readyTime`을 `uint32(now + cooldownTime)`으로 설정해야 하네.
    3. 다음으로, `_isReady`라고 불리는 함수를 만들게. 이 함수 역시 `_zombie`라는 이름의 `Zombie storage` 타입 인수를 받네. `internal view`여야 하고, `bool`을 리턴해야 하네.
    4. 함수의 내용에서는 `(_zombie.readyTime <= now)`를 리턴해야 하고, 이는 `true` 아니면 `false`로 계산될 것이네. 이 함수는 우리에게 좀비가 먹이를 먹은 후 충분한 시간이 지났는지 알려줄 것이네.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefactory.sol";
        
        contract KittyInterface {
          function getKitty(uint256 _id) external view returns (
            bool isGestating,
            bool isReady,
            uint256 cooldownIndex,
            uint256 nextActionAt,
            uint256 siringWithId,
            uint256 birthTime,
            uint256 matronId,
            uint256 sireId,
            uint256 generation,
            uint256 genes
          );
        }
        
        contract ZombieFeeding is ZombieFactory {
        
          KittyInterface kittyContract;
        
          function setKittyContractAddress(address _address) external onlyOwner {
            kittyContract = KittyInterface(_address);
          }
        
          // 1. `_triggerCooldown` 함수를 여기에 정의하게
          function _triggerCooldown(Zombie storage _zombie) internal {
            _zombie.readyTime = uint32(now + cooldownTime);
          }
        
          // 2. `_isReady` 함수를 여기에 정의하게
          function _isReady(Zombie storage _zombie) internal view returns (bool) {
            return (_zombie.readyTime <= now);
          }
        
          function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public {
            require(msg.sender == zombieToOwner[_zombieId]);
            Zombie storage myZombie = zombies[_zombieId];
            _targetDna = _targetDna % dnaModulus;
            uint newDna = (myZombie.dna + _targetDna) / 2;
            if (keccak256(_species) == keccak256("kitty")) {
              newDna = newDna - newDna % 100 + 99;
            }
            _createZombie("NoName", newDna);
          }
        
          function feedOnKitty(uint _zombieId, uint _kittyId) public {
            uint kittyDna;
            (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
            feedAndMultiply(_zombieId, kittyDna, "kitty");
          }
        
        }
        ```
        

### ****Public 함수 & 보안****

- `**feedAndMultiply`를 우리의 재사용 대기 시간 타이머를 고려하도록 수정**
    - 보안을 점검하는 좋은 방법은 자네의 모든 `public`과 `external`함수를 검사하고, 사용자들이 그 함수들을 남용할 수 있는 방법을 생각해보는 것.
    - 이 함수들이 `onlyOwner` 같은 제어자를 갖지 않는 이상, 어떤 사용자든 이 함수들을 호출하고 자신들이 원하는 모든 데이터를 함수에 전달할 수 있음
        - 사용자들은 이 함수를 직접적으로 호출할 수 있고 그들이 원하는 아무 `_targetDna`
        나 `_species`를 전달할 수 있음
        - 이 함수는 오직 `feedOnKitty()`에 의해서만 호출이 될 필요가 있음. 그러니 이런 남용을 막을 가장 쉬운 방법은 이 함수를 `internal`로 만드는 것임.
- 예제)
    1. 현재 `feedAndMultiply`는 `public` 함수이네. 이걸 `internal`로 만들어서 컨트랙트가 더 안전해지도록 하세. 우리는 사용자들이 그들이 원하는 아무 DNA나 넣어서 이 함수를 실행하는 것을 원하지 않네.
    2. `feedAndMultiply` 함수가 `cooldownTime`을 고려하도록 만들어보세. 먼저, `myZombie`를 찾은 후에, `_isReady()`를 확인하는 `require` 문장을 추가하고 거기에 `myZombie`를 전달하게. 이렇게 하면 사용자들은 좀비의 재사용 대기 시간이 끝난 다음에만 이 함수를 실행할 수 있네.
    3. 함수의 끝에서 `_triggerCooldown(myZombie)` 함수를 호출하여 먹이를 먹는 것이 좀비의 재사용 대기 시간을 만들도록 하게.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefactory.sol";
        
        contract KittyInterface {
          function getKitty(uint256 _id) external view returns (
            bool isGestating,
            bool isReady,
            uint256 cooldownIndex,
            uint256 nextActionAt,
            uint256 siringWithId,
            uint256 birthTime,
            uint256 matronId,
            uint256 sireId,
            uint256 generation,
            uint256 genes
          );
        }
        
        contract ZombieFeeding is ZombieFactory {
        
          KittyInterface kittyContract;
        
          function setKittyContractAddress(address _address) external onlyOwner {
            kittyContract = KittyInterface(_address);
          }
        
          function _triggerCooldown(Zombie storage _zombie) internal {
            _zombie.readyTime = uint32(now + cooldownTime);
          }
        
          function _isReady(Zombie storage _zombie) internal view returns (bool) {
              return (_zombie.readyTime <= now);
          }
        
          // 1. 이 함수를 internal로 만들게
          function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal {
            require(msg.sender == zombieToOwner[_zombieId]);
            Zombie storage myZombie = zombies[_zombieId];
            // 2. 여기에 `_isReady`를 확인하는 부분을 추가하게
            require(_isReady(myZombie));
        
            _targetDna = _targetDna % dnaModulus;
            uint newDna = (myZombie.dna + _targetDna) / 2;
            if (keccak256(_species) == keccak256("kitty")) {
              newDna = newDna - newDna % 100 + 99;
            }
            _createZombie("NoName", newDna);
            // 3. `_triggerCooldown`을 호출하게
            _triggerCooldown(myZombie);
          }
        
          function feedOnKitty(uint _zombieId, uint _kittyId) public {
            uint kittyDna;
            (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
            feedAndMultiply(_zombieId, kittyDna, "kitty");
          }
        
        }
        ```
        

### 함수 제어자의 또 다른 특징

- 인수를 가지는 함수 제어자
    - 이전에는 `onlyOwner`라는 간단한 예시를 살펴봄. 하지만 함수 제어자는 사실 인수 또한 받을 수 있음
    - `olderthan`제어자가 함수와 비슷하게 인수를 받는 것을 볼 수 있음. 그리고 `driveCar`
     함수는 받은 인수를 제어자로 전달하고 있음
        
        ```solidity
        // 사용자의 나이를 저장하기 위한 매핑
        mapping (uint => uint) public age;
        
        // 사용자가 특정 나이 이상인지 확인하는 제어자
        modifier olderThan(uint _age, uint _userId) {
          require (age[_userId] >= _age);
          _;
        }
        
        // 차를 운전하기 위햐서는 16살 이상이어야 하네(적어도 미국에서는).
        // `olderThan` 제어자를 인수와 함께 호출하려면 이렇게 하면 되네:
        function driveCar(uint _userId) public olderThan(16, _userId) {
          // 필요한 함수 내용들
        }
        ```
        
- 예제)  특별한 능력에 제한을 걸 수 있도록 좀비의 `level` 속성을 사용하는 우리만의 `modifier`
를 만듬.
    1. `ZombieHelper`에서, `aboveLevel`이라는 이름의 `modifier`를 만들게. 이 제어자는 `_level`(`uint`), `_zombieId`(`uint`) 두 개의 인수를 받을 것이네.
    2. 함수 내용에서는 `zombies[_zombieId].level`이 `_level` 이상인지 확실하게 확인해야 하네.
    3. 함수의 나머지 내용을 실행할 수 있도록 제어자의 마지막 줄에 `_;`를 넣는 것을 잊지 말게.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefeeding.sol";
        
        contract ZombieHelper is ZombieFeeding {
        
          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }
        
        }
        ```
        

### 좀비 제어자

- 우리 게임에서는 사용자들이 그들의 좀비를 레벨업할 때 인센티브를 줄 것.
    - 레벨 2 이상인 좀비인 경우, 사용자들은 그 좀비의 이름을 바꿀 수 있음.
    - 레벨 20 이상인 좀비인 경우, 사용자들은 그 좀비에게 임의의 DNA를 줄 수 있음.
    - 예시)
    
    ```solidity
    // 사용자의 나이를 저장하기 위한 매핑
    mapping (uint => uint) public age;
    
    // 사용자가 특정 나이 이상인지 확인하는 제어자
    modifier olderThan(uint _age, uint _userId) {
      require (age[_userId] >= _age);
      _;
    }
    
    // 차를 운전하기 위햐서는 16살 이상이어야 하네(적어도 미국에서는).
    function driveCar(uint _userId) public olderThan(16, _userId) {
      // 필요한 함수 내용들
    }
    ```
    
- 예제)
    1. `changeName`이라는 함수를 만들게. 이 함수는 2개의 인수를 받을 것이네: `_zombieId`(`uint`), `_newName`(`string`). 그리고 함수를 `external`로 만들게. 이 함수는 `aboveLevel` 제어자를 가져야 하고, `_level`에 `2`라는 값을 전달해야 하네. `_zombieId` 또한 전달하는 것을 잊지 말게나.
    2. 함수의 내용에서는, 먼저 우리는 `msg.sender`가 `zombieToOwner[_zombieId]`와 같은지 검증해야 하네. `require` 문장을 사용하게.
    3. 그리고 나서 이 함수에서는 `zombies[_zombieId].name`에 `_newName`을 대입해야 하네.
    4. `changeName` 아래에 `changeDna`라는 또다른 함수를 만들게. 그리고 함수를 `external`로 만들게. 이 함수의 정의와 내용은 `changeName`과 거의 똑같지만, 두 번째 인수가 `_newDna`(`uint`)이고, `aboveLevel`의 `_level` 매개 변수에 `20`을 전달해야 할 것이네. 물론, 이 함수는 좀비의 이름을 설정하는 것 대신에 좀비의 `dna`를 `_newDna`로 설정해야 하겠지.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefeeding.sol";
        
        contract ZombieHelper is ZombieFeeding {
        
          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }
        
          // 여기서 시작하게
          function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].name = _newName;
          }
        
          function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].dna = _newDna;
          }
        
        }
        ```
        

### ****'View' 함수를 사용해 가스 절약하기****

- ****View 함수는 가스를 소모하지 않음****
    - `view`
     함수는 사용자에 의해 외부에서 호출되었을 때 가스를 전혀 소모하지 않음
    - `view`함수가 블록체인 상에서 실제로 어떤 것도 수정하지 않기 때문. 데이터를 읽기만 함.
    - 함수에 `view` 표시를 하는 것은 `web3.js`에 이렇게 말하는 것과 같음. 
    *"이 함수는 실행할 때  로컬 이더리움 노드에 질의만 날리면 되고, 블록체인에 어떤 트랜잭션도 만들지 않아"*(트랜잭션은 모든 개별 노드에서 실행되어야 하고, 가스를 소모)
        
        > *참고: 만약 `view` 함수가 동일 컨트랙트 내에 있는, `view` 함수가 **아닌** 다른 함수에서 내부적으로 호출될 경우, 여전히 가스를 소모할 것이네. 이것은 다른 함수가 이더리움에 트랜잭션을 생성하고, 이는 모든 개별 노드에서 검증되어야 하기 때문이네. 그러니 `view` 함수는 외부에서 호출됐을 때에만 무료라네.*
        > 
- 예제)  사용자의 전체 좀비 군대를 반환하는 함수를 구현할 것. 만약 사용자들의 프로필 페이지에 그들의 전체 군대를 표시하고 싶다면, 나중에 이 함수를 `web3.js`에서 호출하면 된다.
    1. `getZombiesByOwner`라는 이름의 함수를 만들게. 이 함수는 `_owner`라는 이름의 `address`를 하나의 인수로 받을 것이네.
    2. 이걸 `external view` 함수로 만들게. 우리는 이 함수를 `web3.js`에서 가스를 쓸 필요 없이 호출할 수 있을 것이네.
    3. 이 함수는 `uint[]`를 반환해야 하네(`uint`의 배열).
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefeeding.sol";
        
        contract ZombieHelper is ZombieFeeding {
        
          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }
        
          function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].name = _newName;
          }
        
          function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].dna = _newDna;
          }
        
          // 자네의 함수를 여기에 만들게
          function getZombiesByOwner(address _owner) external view returns(uint[]){
            
          }
        
        }
        ```
        

### ****Storage는 비쌈****

- 솔리디티에서 더 비싼 연산 중 하나는 바로 `storage`를 쓰는 것 - 그중에서도 쓰기 연산
    - 데이터의 일부를 쓰거나 바꿀 때마다, 블록체인에 영구적으로 기록되기 때문. 영원히, 지구상의 수천 개의 노드들이 그들의 하드 드라이브에 그 데이터를 저장해야 하고, 블록체인이 커져가면서 이 데이터의 양 또한 같이 커져감.
    - 비용을 최소화하기 위해서, 진짜 필요한 경우가 아니면 storage에 데이터를 쓰지 않는 것이 좋음
    - 이를 위해 때때로는 겉보기에 비효율적으로 보이는 프로그래밍 구성을 할 필요가 있음 
    - 어떤 배열에서 내용을 빠르게 찾기 위해, 단순히 변수에 저장하는 것 대신 함수가 호출될 때마다 배열을 `memory`에 다시 만드는 것처럼.
    - 대부분의 프로그래밍 언어에서는, 큰 데이터 집합의 개별 데이터에 모두 접근하는 것은 비용이 비쌈.
    - 하지만 솔리디티에서는 그 접근이 `external view` 함수라면 `storage`를 사용하는 것보다 더 저렴한 방법. `view`함수는 사용자들의 가스를 소모하지 않기 때문.
- 메모리에 배열 선언
    - Storage에 아무것도 쓰지 않고도 함수 안에 새로운 배열을 만들려면 배열에 `memory`키워드를 쓰면 됨.
    - 이 배열은 함수가 끝날 때까지만 존재할 것이고, 이는 `storage`의 배열을 직접 업데이트하는 것보다 가스 소모 측면에서 훨씬 저렴. - 외부에서 호출되는 `view`함수라면 무료
    - 예시)
    
    ```solidity
    function getArray() external pure returns(uint[]) {
      // 메모리에 길이 3의 새로운 배열을 생성한다.
      uint[] memory values = new uint[](3);
      // 여기에 특정한 값들을 넣는다.
      values.push(1);
      values.push(2);
      values.push(3);
      // 해당 배열을 반환한다.
      return values;
    }
    ```
    
    > *참고: 메모리 배열은 **반드시** 길이 인수와 함께 생성되어야 함(이 예시에서는, `3`). 메모리 배열은 현재로서는 storage 배열처럼 `array.push()`로 크기가 조절되지는 않음.*
    > 
- 예제) `getZombiesByOwner`함수에서, 우리는 특정한 사용자가 소유한 모든 좀비를 `uint[]`배열로 반환
    1. `result`라는 이름의 `uint[] memory` 변수를 선언하게.
    2. 해당 변수에 `uint` 배열을 대입하게. 배열의 길이는 이 `_owner`가 소유한 좀비의 개수여야 하고, 이는 우리의 `mapping`인 `ownerZombieCount[_owner]`를 통해서 찾을 수 있네.
    3. 함수의 끝에서 `result`를 반환하게. 지금 당장은 빈 배열이지만, 다음 챕터에서 이를 채울 것이네.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefeeding.sol";
        
        contract ZombieHelper is ZombieFeeding {
        
          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }
        
          function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].name = _newName;
          }
        
          function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].dna = _newDna;
          }
        
          function getZombiesByOwner(address _owner) external view returns(uint[]) {
            // 여기서 시작하게
            uint[] memory result = new uint[](ownerZombieCount[_owner]);
            return result;
          }
        
        }
        ```
        

### For 반복문

- 기존 방식
    - `getZombiesByOwner`를 구현할 때, 기초적인 구현 방법은 `ZombieFactory` 컨트랙트에서 소유자의 좀비 군대에 대한 `mapping`을 만들어 저장
    
    ```solidity
    mapping (address => uint[]) public ownerToZombies
    ```
    
    - 새로운 좀비를 만들 때마다, 해당 소유자의 좀비 배열에 `ownerToZombies[owner].push(zombieId)`를 사용해서 새 좀비를 추가
    
    ```solidity
    function getZombiesByOwner(address _owner) external view returns (uint[]) {
      return ownerToZombies[_owner];
    }
    ```
    
- 기존 방식의 문제
    - 만약 나중에 한 좀비를 원래 소유자에서 다른 사람에게 전달하는 함수를 구현시 문제점
        - 좀비 전달 함수는 이런 내용이 필요
        1. 전달할 좀비를 새로운 소유자의 `ownerToZombies` 배열에 넣는다.
        2. 기존 소유자의 `ownerToZombies` 배열에서 해당 좀비를 지운다.
        3. 좀비가 지워진 구멍을 메우기 위해 소유자의 배열에서 모든 좀비를 한 칸씩 움직인다.
        4. 배열의 길이를 1 줄인다.
    - 3번째 단계는 극단적으로 가스 소모가 많음. 위치를 바꾼 **모든** 좀비에 대해 쓰기 연산을 해야 하기 때문. 소유자가 20마리의 좀비를 가지고 있고 첫 번째 좀비를 거래한다면, 배열의 순서를 유지하기 위해 우린 19번의 쓰기를 해야 할 것.
    - 더 안 좋은 점은, 이 함수가 실행될 때마다 다른 양의 가스를 소모할 것이라는 점. 사용자가 자신의 군대에 얼마나 많은 좀비를 가지고 있는지, 또 거래되는 좀비의 인덱스에 따라 달라짐. 즉 사용자들은 거래에 가스를 얼마나 쓰게 될지 알 수 없음.
        
        > 참고: 물론, 빈 자리를 채우기 위해 마지막 좀비를 움직인 다음, 배열의 길이를 하나 줄여도 되겠지. 하지만 그렇게 하면 교환이 일어날 때마다 좀비 군대의 순서가 바뀌게 될 것.
        > 
    - `view` 함수는 외부에서 호출될 때 가스를 사용하지 않기 때문에, 우린 `getZombiesByOwner`
     함수에서 for 반복문을 사용해서 좀비 배열의 모든 요소에 접근한 후 특정 사용자의 좀비들로 구성된 배열을 만들 수 있을 것. 그러고 나면 `transfer` 함수는 훨씬 비용을 적게 쓰게 됨. 왜냐하면 storage에서 어떤 배열도 재정렬할 필요가 없기 때문. 일반적인 직관과는 반대로 이런 접근법이 전체적으로 비용 소모가 더 적음.
- For 반복문 사용하기
    - 예시 : 짝수로 구성된 배열 만들기
    
    ```solidity
    function getEvens() pure external returns(uint[]) {
      uint[] memory evens = new uint[](5);
      // 새로운 배열의 인덱스를 추적하는 변수
      uint counter = 0;
      // for 반복문에서 1부터 10까지 반복함
      for (uint i = 1; i <= 10; i++) {
        // `i`가 짝수라면...
        if (i % 2 == 0) {
          // 배열에 i를 추가함
          evens[counter] = i;
          // `evens`의 다음 빈 인덱스 값으로 counter를 증가시킴
          counter++;
        }
      }
      return evens;
    }
    ```
    
- 예제) 반복문 안에서는 우리 DApp 안에 있는 모든 좀비들에 접근하고, 그들의 소유자가 우리가 찾는 자인지 비교하여 확인한 후, 조건에 맞는 좀비들을 `result` 배열에 추가한 후 반환
    - 이 함수는 이제 `_owner`가 소유한 모든 좀비를 가스를 소모하지 않고 반환하게 될 것.
    1. `counter`라는 이름의 `uint`를 하나 선언하고 `0`을 대입하게. 우린 `result` 배열에서 인덱스를 추적하기 위해 이 변수를 사용할 것이네.
    2. `uint i = 0`에서 시작해서 `i < zombies.length`까지 증가하는 `for` 반복문을 선언하게. 이 반복문에서 우리 배열의 모든 좀비에 접근할 것이네.
    3. `for` 반복문 안에서, `zombieToOwner[i]`가 `_owner`와 같은지 확인하는 `if` 문장을 만들게. 이 문장은 두 개의 주소값이 같은지 비교하는 것이네.
    4. `if` 문장 안에서:
        1. `result[counter]`에 `i`를 대입해서 `result` 배열에 좀비의 ID를 추가하게.
        2. `counter`를 1 증가시키게(위의 `for` 반복문 예시를 참고하게).
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefeeding.sol";
        
        contract ZombieHelper is ZombieFeeding {
        
          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }
        
          function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].name = _newName;
          }
        
          function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].dna = _newDna;
          }
        
          function getZombiesByOwner(address _owner) external view returns(uint[]) {
            uint[] memory result = new uint[](ownerZombieCount[_owner]);
            // 여기서 시작하게
            uint counter = 0;
            for (uint i = 0; i < zombies.length; i++) {
              if (zombieToOwner[i] == _owner) {
                result[counter] = i;
                counter++;
              }
            }
            return result;
          }
        
        }
        ```
        

### 마무리

- 요약
    - CryptoKitties 컨트랙트를 변경하는 한 가지 방법을 배웠네
    - `onlyOwner`를 이용해 핵심적인 함수를 보호하는 방법을 배웠네
    - 가스와 가스 사용 최적화에 대해 배웠네
    - 우리 좀비들에게 레벨과 대기시간 개념을 적용했네
    - 좀비가 특정 레벨이 되면 좀비의 이름과 DNA를 재설정할 수 있는 함수를 만들었네
    - 마지막으로, 사용자의 좀비 군대를 반환하는 함수를 만들었네.