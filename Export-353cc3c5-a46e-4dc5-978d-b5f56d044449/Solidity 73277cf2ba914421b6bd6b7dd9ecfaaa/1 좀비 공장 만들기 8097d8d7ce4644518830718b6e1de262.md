# 1. 좀비 공장 만들기

---

---

### 레슨 개요

- 좀비 데이터베이스 유지
- 좀비 생성 함수
- 좀비 외모 랜덤
- 좀비 DNA 활용 방법
    - 16자리 정수 ex)8356382049284737
    - 처음 2자리 머리 타입 연결, 그 다음 2자리 눈 모양 연결
        
        > 참고: 2자리 숫자로 100가지의 경우의 수 구할 수 있음
        > 
    - 좀비 머리 매핑
        - 83 % 7 + 1 = 7
        - 이 DNA는 7번째 좀비 머리 타입
        

### 컨트랙트

- 컨트랙트는 이더리움 어플리케이션의 기본적인 구성 요소
- 모븐 변수와 함수는 컨트랙트에 속함
- 모든 프로젝트의 시작 지점
    - 비어있는 HelloWorld 컨트랙트
        
        ```solidity
        contract HelloWorld {
        
        }
        ```
        

- Version Pragma
- 모든 솔리디티 코드는 “Version Pragma”로 시작, 이는 이용하는 버전 선언
- 선언
    
    ```solidity
    pragma solidity ^0.4.19;
    
    contract HelloWorld {
    
    }
    ```
    

### 상태 변수 & 정수

- uint : 부호 없는 정수
    - uint는 uint256, 즉 256비트 부호없는 정수 uint8, uint16, uint32 도 있음
- int : 부호 있는 정수
- 변수 선언
    
    ```solidity
    contract Example {
      // 이 변수는 블록체인에 영구적으로 저장된다
      uint myUnsignedInteger = 100;
    }
    ```
    

### 수학 연산

- 연산은 대부분 프로그래밍 언어의 수학 연산과 동일
    - 덧셈: `x + y`
    - 뺄셈: `x - y`,
    - 곱셈: `x * y`
    - 나눗셈: `x / y`
    - 모듈로 / 나머지: `x % y`
    - 지수 연산 지원 : `x ** y`

- DNA 16자리 숫자 고정
    - uint 변수 생성 후 10^16값 배정, 값을 모듈로 연산자 `%` 와 함께 이용하여 16 보다 큰 수를 16 자리 숫자로
    - 예제)
        
        ```solidity
        pragma solidity ^0.4.19;
        
        contract ZombieFactory {
        
            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;
        
        }
        ```
        

### 구조체

- 구조체 선언
    
    ```solidity
    struct Person {
      uint age;
      string name;
    }
    ```
    
- 예제)
    
    ```solidity
    pragma solidity ^0.4.19;
    
    contract ZombieFactory {
    
        uint dnaDigits = 16;
        uint dnaModulus = 10 ** dnaDigits;
    
        struct Zombie{
            string name;
            uint dna;
        }
    }
    ```
    

### 배열

- 정적 배열 / 동적 배열
    - 구조체에 배열을 생성 가능

```solidity
**// 2개의 원소를 담을 수 있는 고정 길이의 배열:
uint[2] fixedArray;
// 또다른 고정 배열으로 5개의 스트링을 담을 수 있다:
string[5] stringArray;
// 동적 배열은 고정된 크기가 없으며 계속 크기가 커질 수 있다:
uint[] dynamicArray;**
```

- public 배열
    - public으로 배열 선언 가능
    - 솔리디티는 이런 배열을 위해 `getter()` 메소드를 자동 생성
        
        ```solidity
        Person[] public people;
        ```
        
- 예제) 앱에 좀비 군대 저장 및 우리 좀비를 다른 앱에 자랑
    
    ```solidity
    pragma solidity ^0.4.19;
    
    contract ZombieFactory {
    
        uint dnaDigits = 16;
        uint dnaModulus = 10 ** dnaDigits;
    
        struct Zombie {
            string name;
            uint dna;
        }
    
        Zombie[] public zombies;
    
    }
    ```
    

### 함수 선언

- 함수 선언
    
    ```solidity
    function eatHamburgers(string _name, uint _amount) {
    
    }
    ```
    
- 함수 호출
    
    ```solidity
    eatHamburgers("vitalik", 100);
    ```
    
- 좀비 생성 함수 생성
    - 1. `createZombie`라는 함수를 생성한다. 이 함수는 다음 2개의 인자를 전달받아야 한다: **_name** (`string`형)과 **_dna** (`uint`형).
        
        ```solidity
        pragma solidity ^0.4.19;
        
        contract ZombieFactory {
        
            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;
        
            struct Zombie {
                string name;
                uint dna;
            }
        
            Zombie[] public zombies;
        
            function createZombie(string _name, uint _dna)   {
        
            }
        }
        ```
        

### 구조체와 배열 활용

- 새로운 구조체 생성
    - Person 구조체
        
        ```solidity
        struct Person {
          uint age;
          string name;
        }
        
        Person[] public people;
        ```
        
    - 새로운 Person를 생성, people 배열에 추가
        
        ```solidity
        // 새로운 사람을 생성한다:
        Person satoshi = Person(172, "Satoshi");
        
        // 이 사람을 배열에 추가한다:
        people.push(satoshi);
        ```
        
        ```solidity
        people.push(Person(16, "Vitalik"));
        ```
        
    - `array.push()`는 무언가를 배열의 끝에 추가해서 모든 원소가 순서를 유지
        - 예제)
        
        ```solidity
        uint[] numbers;
        numbers.push(5);
        numbers.push(10);
        numbers.push(15);
        // numbers 배열은 [5, 10, 15]과 같다.
        ```
        
- 예제)
    1. 함수에 코드를 넣어 새로운 `Zombie`를 생성하여 `zombies` 배열에 추가하도록 한다. 새로운 좀비를 위한 `name`과 `dna`는 `createZombie`함수의 인자값이어야 한다.
    2. 코드를 한 줄로 간결하게 작성해 보자.
    
    ```solidity
    pragma solidity ^0.4.19;
    
    contract ZombieFactory {
    
        uint dnaDigits = 16;
        uint dnaModulus = 10 ** dnaDigits;
    
        struct Zombie {
            string name;
            uint dna;
        }
    
        Zombie[] public zombies;
    
        function createZombie(string _name, uint _dna) {
            zombies.push(Zombie(_name, _dna));
        }
    
    }
    ```
    

### Private / Public 함수

- 함수는 기본적으로 `public`으로 선언
- 컨트랙트 공격에 취약해짐
- 개발시 기본적으로 `private`으로 선언하고, 공개할 함수만`public`
으로 선언
- `private` 함수 선언
    - `private`는 컨트랙트 내의 다른 함수들만이 이 함수 호출
    - `private` 키워드는 함수명 다음, 인자명과 마친가지로 `private` 함수명도 언더바로 시작 관례
    
    ```solidity
    uint[] numbers;
    
    function _addToArray(uint _number) private {
      numbers.push(_number);
    }
    ```
    
- 예제
    
    1. `createZombie` 함수를 변경하여 private 함수로 만든다. 함수명에 대한 관례
    
    ```solidity
    pragma solidity ^0.4.19;
    
    contract ZombieFactory {
    
        uint dnaDigits = 16;
        uint dnaModulus = 10 ** dnaDigits;
    
        struct Zombie {
            string name;
            uint dna;
        }
    
        Zombie[] public zombies;
    
        function _createZombie(string _name, uint _dna) private {
            zombies.push(Zombie(_name, _dna));
        }
    }
    ```
    

### 함수 더 알아 보기

- 반환값
    - 솔리디티에서 함수 선언은 반환값 종류를 포함 (이 경우에는 string).
    
    ```solidity
    string greeting = "What's up dog";
    
    function sayHello() public returns (string) {
      return greeting;
    }
    ```
    
- 함수 제어자
    - `View` 함수 : 함수가 데이터를 보기만 하고 변경하지 않음
        - 솔리디티에서 상태 변화 시키지않는 함수는 `View`
         함수로 선언
        
        ```solidity
        function sayHello() public view returns (string) {}
        ```
        
    - `pure` 함수 : 함수가 앱에서 어떤 데이터도 접근하지 않는 것을 의미
        - 이 함수는 앱에서 읽는 것도 하지 않고, 다만 반환값이 함수에 전달된 인자값에 따라서 달라진다.
        
        ```solidity
        function _multiply(uint a, uint b) private pure returns (uint) {
          return a * b;
        }
        ```
        
- 예제) 스트링으로부터 랜덤 DNA 숫자를 생성하는 도우미 함수가 필요
    1. `_generateRandomDna`라는 `private` 함수를 만든다. 이 함수는 `_str` (`string`형)을 인자로 전달받고, `uint`을 반환.
    2. 이 함수는 컨트랙트 변수를 보지만 변경하지는 않을 것이므로 `view`로 선언.
    3. 이 함수의 내용은 현재로서는 비어 있는 상태.
        
        ```solidity
        pragma solidity ^0.4.19;
        
        contract ZombieFactory {
        
            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;
        
            struct Zombie {
                string name;
                uint dna;
            }
        
            Zombie[] public zombies;
        
            function _createZombie(string _name, uint _dna) private {
                zombies.push(Zombie(_name, _dna));
            } 
        
            function _generateRandomDna(string _str) private view returns (uint) {
                
            }
        }
        ```
        

### Keccak256과 형 변환

- _generateRandomDna 함수의 반환값이 랜덤인 uint만들기
    - 이더리움은 SHA3의 한 버전인 keccak256를 내장 해시 함수로 가지고있다. 해시함수는 기본적으로 입력 스트링을 랜덤 256비트 16진수로 매핑한다. 스트링의 약간의 변화라도 있으면 해시 값은 크게 달라진다.
    - 해시함수는 이더리움에서 여러 용도로 활용 되지만, 여기서는 의사 난수 발생기로 이용
    
    ```solidity
    //6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5
    keccak256("aaaab");
    //b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9
    keccak256("aaaac");
    ```
    
    > 참고 : 블록체인에서 안전한 의사 난수 발생기는 매우 어려운 문제 이다. 여기서 사용한 방법은 안전하지 않지만, 현재 보안이 최우선이 아니라 목적에 적합하다.
    > 
- 형 변환
    - 예시)
        
        ```solidity
        uint8 a = 5;
        uint b = 6;
        // a * b가 uint8이 아닌 uint를 반환하기 때문에 에러 메시지가 난다:
        uint8 c = a * b; 
        // b를 uint8으로 형 변환해서 코드가 제대로 작동하도록 해야 한다:
        uint8 c = a * uint8(b);
        ```
        
        - 위 예시에서 `a * b`는 `uint`를 반환. 반환값을 `uint8` 에 저장하려 하니 잠재적으로 문제 야기. 반환값을 `uint8`으로 형 변환하면 코드가 제대로 작동하고 컴파일러도 에러 메세지 없음
        
    - 예제)
        1. 코드 첫 줄에서는 `_str`을 이용한 `keccak256` 해시값을 받아서 의사 난수 16진수를 생성하고 이를 `uint`로 형 변환한 다음, `rand`라는 `uint`에 결과값을 저장해야 한다.
        2. 우리는 좀비의 DNA가 16자리 숫자이기만을 원하므로(`dnaModulus`를 기억하나?) 코드의 두번째 줄에서는 위의 결과 값을 모듈로(`%`) `dnaModulus`로 연산한 값을 반환해야 한다. (형식: `return` `위의 결과 값` `%` `dnaModulus`).
            
            ```solidity
            pragma solidity ^0.4.19;
            
            contract ZombieFactory {
            
                uint dnaDigits = 16;
                uint dnaModulus = 10 ** dnaDigits;
            
                struct Zombie {
                    string name;
                    uint dna;
                }
            
                Zombie[] public zombies;
            
                function _createZombie(string _name, uint _dna) private {
                    zombies.push(Zombie(_name, _dna));
                } 
            
                function _generateRandomDna(string _str) private view returns (uint) {
                    uint rand = uint(keccak256(_str));
                    return rand % dnaModulus;
                }
            
            }
            ```
            

### 종합하기

- 예제) 랜덤 좀비 생성기 : 모든 애용을 종합하는 public 함수 생성. 좀비의 이름을 입력값으로 받아 랜덤 DNA를 가진 좀비를 만드는 public함수를 생성함
    1. `createRandomZombie`라는 `public`함수를 생성한다. 이 함수는 `_name`이라는 `string`형 인자를 하나 전달받는다. *(참고: 함수를 `private`로 선언한 것과 마찬가지로 함수를 `public`로 생성할 것)*
    2. 이 함수의 첫 줄에서는 `_name`을 전달받은 `_generateRandomDna` 함수를 호출하고, 이 함수의 반환값을 `randDna`라는 `uint`형 변수에 저장해야 한다.
    3. 두번째 줄에서는 `_createZombie` 함수를 호출하고 이 함수에 `_name`와 `randDna`를 전달해야 한다.
    4. 함수의 내용을 닫는 `}`를 포함해서 코드가 4줄이어야 한다.
        
        ```solidity
        pragma solidity ^0.4.19;
        
        contract ZombieFactory {
        
            // 여기에 이벤트 선언
        
            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;
        
            struct Zombie {
                string name;
                uint dna;
            }
        
            Zombie[] public zombies;
        
            function _createZombie(string _name, uint _dna) private {
                zombies.push(Zombie(_name, _dna));
                // 여기서 이벤트 실행
            }
        
            function _generateRandomDna(string _str) private view returns (uint) {
                uint rand = uint(keccak256(_str));
                return rand % dnaModulus;
            }
        
            function createRandomZombie(string _name) public {
                uint randDna = _generateRandomDna(_name);
                _createZombie(_name, randDna);
            }
        
        }
        ```
        

### 이벤트

- 이벤트는 컨트랙트가 블록체인 상에서 앱의 사용자 단에서 무언가 액션이 발생했을때 의사소통하는 방법. 컨트랙트는 특정 이벤트가 일어나는지 “lessen”하고 그 이벤트가 발생하면 행동함.
    - 예시
    
    ```solidity
    // 이벤트를 선언한다
    event IntegersAdded(uint x, uint y, uint result);
    
    function add(uint _x, uint _y) public {
      uint result = _x + _y;
      // 이벤트를 실행하여 앱에게 add 함수가 실행되었음을 알린다:
      IntegersAdded(_x, _y, result);
      return result;
    }
    ```
    
    - 앱의 사용자 단은 해당 이벤트가 일어나는지 귀를 기우린다. 자바스크립트로 이를 구현
        
        ```jsx
        YourContract.IntegersAdded(function(error, result) {
          // 결과와 관련된 행동을 취한다
        })
        ```
        
- 예제) 좀비가 생성될 때마다 앱의 사용자 단에서 이에 대해 알고, 이를 표시하도록 하는 이벤트
    1. `NewZombie`라는 `event`를 선언한다. `zombieId` (`uint`형), `name` (`string`형), `dna` (`uint`형)을 인자로 전달받아야 한다.
    2. `_createZombie` 함수를 변경하여 새로운 좀비가 `zombies` 배열에 추가된 후에 `NewZombie` 이벤트를 실행하도록 한다.
    3. 이벤트를 위해 좀비의 `id`가 필요할 것이다. `array.push()`는 배열의 새로운 길이를 `uint`형으로 반환한다. 배열의 첫 원소가 0이라는 인덱스를 갖기 때문에, `array.push() - 1`은 막 추가된 좀비의 인덱스가 될 것이다. `zombies.push() - 1`의 결과값을 `uint`형인 `id`로 저장하고 이를 다음 줄에서 `NewZombie` 이벤트를 위해 활용한다.
        
        ```solidity
        pragma solidity ^0.4.19;
        
        contract ZombieFactory {
        
            event NewZombie(uint zombieId, string name, uint dna);
        
            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;
        
            struct Zombie {
                string name;
                uint dna;
            }
        
            Zombie[] public zombies;
        
            function _createZombie(string _name, uint _dna) private {
                uint id = zombies.push(Zombie(_name, _dna)) - 1;
                NewZombie(id, _name, _dna);
            }
        
            function _generateRandomDna(string _str) private view returns (uint) {
                uint rand = uint(keccak256(_str));
                return rand % dnaModulus;
            }
        
            function createRandomZombie(string _name) public {
                uint randDna = _generateRandomDna(_name);
                _createZombie(_name, randDna);
            }
        
        }
        ```
        

### Web3.js

- 컨트랙트와 상호작용하는 사용자 단의 자바스크립트 작성
- 이더리움은 ***Web3.js***라고 하는 자바스크립트 라이브러리
- Web3.js가 구축된 컨트랙트와 어떤 방식으로 상호작용 샘플
    
    ```solidity
    // 여기에 우리가 만든 컨트랙트에 접근하는 방법을 제시한다:
    var abi = /* abi generated by the compiler */
    var ZombieFactoryContract = web3.eth.contract(abi)
    var contractAddress = /* our contract address on Ethereum after deploying */
    var ZombieFactory = ZombieFactoryContract.at(contractAddress)
    // `ZombieFactory`는 우리 컨트랙트의 public 함수와 이벤트에 접근할 수 있다.
    
    // 일종의 이벤트 리스너가 텍스트 입력값을 취한다:
    $("#ourButton").click(function(e) {
      var name = $("#nameInput").val()
      // 우리 컨트랙트의 `createRandomZombie`함수를 호출한다:
      ZombieFactory.createRandomZombie(name)
    })
    
    // `NewZombie` 이벤트가 발생하면 사용자 인터페이스를 업데이트한다
    var event = ZombieFactory.NewZombie(function(error, result) {
      if (error) return
      generateZombie(result.zombieId, result.name, result.dna)
    })
    
    // 좀비 DNA 값을 받아서 이미지를 업데이트한다
    function generateZombie(id, name, dna) {
      let dnaStr = String(dna)
      // DNA 값이 16자리 수보다 작은 경우 앞 자리를 0으로 채운다
      while (dnaStr.length < 16)
        dnaStr = "0" + dnaStr
    
      let zombieDetails = {
        // 첫 2자리는 머리의 타입을 결정한다. 머리 타입에는 7가지가 있다. 그래서 모듈로(%) 7 연산을 하여
        // 0에서 6 중 하나의 값을 얻고 여기에 1을 더해서 1에서 7까지의 숫자를 만든다. 
        // 이를 기초로 "head1.png"에서 "head7.png" 중 하나의 이미지를 불러온다:
        headChoice: dnaStr.substring(0, 2) % 7 + 1,
        // 두번째 2자리는 눈 모양을 결정한다. 눈 모양에는 11가지가 있다:
        eyeChoice: dnaStr.substring(2, 4) % 11 + 1,
        // 셔츠 타입에는 6가지가 있다:
        shirtChoice: dnaStr.substring(4, 6) % 6 + 1,
        // 마지막 6자리는 색깔을 결정하며, 360도(degree)까지 지원하는 CSS의 "filter: hue-rotate"를 이용하여 아래와 같이 업데이트된다:
        skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360),
        eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360),
        clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360),
        zombieName: name,
        zombieDescription: "A Level 1 CryptoZombie",
      }
      return zombieDetails
    }
    ```