# 4.좀비 전투 시스템

### Payable

- 함수 제어자 정리
    1. 우린 함수가 언제, 어디서 호출될 수 있는지 제어하는 접근 제어자(visibility modifier)를 알게 되었음: `private`은 컨트랙트 내부의 다른 함수들에서만 호출될 수 있음을 의미. 
    `internal`은 `private`과 비슷하지만, 해당 컨트랙트를 상속하는 컨트랙트에서도 호출될 수 있음. `external`은 오직 컨트랙트 외부에서만 호출될 수 있음. 마지막으로 `public`은 내외부 모두에서, 어디서든 호출될 수 있음.
    2. 상태 제어자(state modifier): 이 제어자는 블록체인과 상호작용 하는 방법에 대해 알려줌:
     `view`는 해당 함수를 실행해도 어떤 데이터도 저장/변경되지 않음을 알려줌. `pure`는 해당 함수가 어떤 데이터도 블록체인에 저장하지 않을 뿐만 아니라, 블록체인으로부터 어떤 데이터도 읽지 않음을 알려줌. 이들 모두는 컨트랙트 외부에서 불렸을 때 가스를 전혀 소모하지 않음(하지만 다른 함수에 의해 내부적으로 호출됐을 경우에는 가스를 소모).
    3. 사용자 정의 `제어자` : 예를 들자면 `onlyOwner`와 `aboveLevel` 같은 것. 이런 제어자를 사용해서 우린 함수에 이 제어자들이 어떻게 영향을 줄지를 결정하는 우리만의 논리를 구성할 수 있음.
    - 제어제들을 함수 하나에 사용
    
    ```solidity
    function test() external view onlyOwner anotherModifier { /* ... */ }
    ```
    
- payable 제어자
    - `payable`함수 : 이더를 받을 수 있는 특별한 함수 유형
        - 일반적인 웹 서버에서 API 함수를 실행할 때에는,함수 호출을 통해서 US 달러를 보낼 수 없음
        - 이더리움에서는, 돈(_이더_), 데이터(*transaction payload*), 그리고 컨트랙트 코드 자체 
        모두 이더리움 위에 존재하기 때문에, 자네가 함수를 실행하는 **동시에** 컨트랙트에 돈을 지불하는 것이 가능
    - 예시
        
        ```solidity
        contract OnlineStore {
          function buySomething() external payable {
            // 함수 실행에 0.001이더가 보내졌는지 확실히 하기 위해 확인:
            require(msg.value == 0.001 ether);
            // 보내졌다면, 함수를 호출한 자에게 디지털 아이템을 전달하기 위한 내용 구성:
            transferThing(msg.sender);
          }
        }
        ```
        
        - `msg.value`
        는 컨트랙트로 이더가 얼마나 보내졌는지 확인하는 방법이고, `ether`는 기본적으로 포함된 단위
    - 누군가 web3.js(DApp의 자바스크립트 프론트엔드)에서 다음과 같이 함수를 실행할 때 발생
        
        ```solidity
        // `OnlineStore`는 자네의 이더리움 상의 컨트랙트를 가리킨다고 가정하네:
        OnlineStore.buySomething({from: web3.eth.defaultAccount, value: web3.utils.toWei(0.001)})
        ```
        
        - `value` 필드를 주목하면, 자바스크립트 함수 호출에서 이 필드를 통해 `ether`를 얼마나 보낼지 결정. 트랜잭션을 봉투로 생각하고, 함수 호출에 전달하는 매개 변수를 써넣은 편지의 내용이라 생각한다면, `value`는 봉투 안에 현금을 넣는 것과 같음. 
        - 편지와 돈이 모두 수령인에게 전달.
            
            > *참고: 만약 함수가 `payable`로 표시되지 않았는데 자네가 위에서 본 것처럼 이더를 보내려 한다면, 함수에서 자네의 트랜잭션을 거부할 것.*
            > 
- 예제) 좀비의 레벨업을 위해 사용자들이 ETH를 지불할 수 있는 기능이 있다고 가정. ETH는  소유한 컨트랙트에 저장될 것 - 이는 게임을 통해 자네가 돈을 벌 수 있는 간단한 예시
    1. `uint` 타입의 `levelUpFee` 변수를 정의하고, 여기에 `0.001 ether`를 대입하게.
    2. `levelUp`이라는 함수를 생성하게. 이 함수는 `_zombieId`라는 `uint` 타입의 매개변수 하나를 받을 것이네. 함수는 `external`이면서 `payable`이어야 하네.
    3. 이 함수는 먼저 `msg.value`가 `levelUpFee`와 같은지 `require`로 확인해야 하네.
    4. 그리고서 좀비의 `level`을 증가시켜야 하네: `zombies[_zombieId].level++`. 
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefeeding.sol";
        
        contract ZombieHelper is ZombieFeeding {
        
          // 1. 여기에 levelUpFee를 정의하게
          uint levelUpFee = 0.001 ether;
        
          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }
        
          // 2. 여기에 levelUp 함수를 삽입하게
          function levelUp(uint _zombieId) external payable {
            require(msg.value == levelUpFee);
            zombies[_zombieId].level++;
          }
        
          function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].name = _newName;
          }
        
          function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].dna = _newDna;
          }
        
          function getZombiesByOwner(address _owner) external view returns(uint[]) {
            uint[] memory result = new uint[](ownerZombieCount[_owner]);
            uint counter = 0;
            for (uint i = 0; i < zombies.length; i++) {
              if (zombieToOwner[i] == _owner) {
                result[counter] = i;
                counter++;
              }
            }
            return result;
          }
        
        }
        ```
        

### 출금

- 컨트랙트에서 이더를 인출하는 함수
    
    ```solidity
    contract GetPaid is Ownable {
      function withdraw() external onlyOwner {
        owner.transfer(this.balance);
      }
    }
    ```
    
    - `transfer` 함수를 사용해서 이더를 특정 주소로 전달할 수 있음.
    - `this.balance`는 컨트랙트에 저장돼있는 전체 잔액을 반환.
        - 100명의 사용자가 우리의 컨트랙트에 1이더를 지불했다면, `this.balance`는 100이더가 될 것.
    - `transfer` 함수를 써서 특정한 이더리움 주소에 돈을 보낼 수 있음.
        - 예를 들어, 만약 누군가 한 아이템에 대해 초과 지불을 했다면, 이더를 `msg.sender`
        로 되돌려주는 함수를 만들 수도 있음.
        
        ```solidity
        uint itemFee = 0.001 ether;
        msg.sender.transfer(msg.value - itemFee);
        ```
        
    - 구매자와 판매자가 존재하는 컨트랙트에서, 판매자의 주소를 storage에 저장하고, 누군가 판매자의 아이템을 구매하면 구매자로부터 받은 요금을 그에게 전달할 수도 있음
        
        ```solidity
        seller.transfer(msg.value).
        ```
        
- 예제)
    1. 우리 컨트랙트에 `withdraw` 함수를 생성하게. 이 함수는 위에서 본 `GetPaid` 예제와 동일해야 하네.
    2. 이더의 가격은 과거에 비해 10배 이상 뛰었네. 그러니 지금 이 글을 쓰는 시점에서는 0.001이더가 1달러 정도 되지만, 만약 이게 다시 10배가 되면 0.001 ETH는 10달러가 될 것이고 우리의 게임은 더 비싸질 것이네.
    그러니 컨트랙트의 소유자로서 우리가 `levelUpFee`를 설정할 수 있도록 하는 함수를 만드는 것이 좋겠지.
        1. `setLevelUpFee`라는 이름의, `uint _fee`를 하나의 인자로 받고 `external이`며 `onlyOwner` 제어자를 사용하는 함수를 생성하게.
        2. 이 함수는 `levelUpFee`를 `_fee`로 설정해야 하네.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefeeding.sol";
        
        contract ZombieHelper is ZombieFeeding {
        
          uint levelUpFee = 0.001 ether;
        
          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }
        
          // 1. 여기에 withdraw 함수를 생성하게
          function withdraw() external onlyOwner {
            owner.transfer(this.balance);
          }
        
          // 2. 여기에 setLevelUpFee를 생성하게
          function setLevelUpFee(uint _fee) external onlyOwner {
            levelUpFee = _fee;
          } 
        
          function levelUp(uint _zombieId) external payable {
            require(msg.value == levelUpFee);
            zombies[_zombieId].level++;
          }
        
          function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].name = _newName;
          }
        
          function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].dna = _newDna;
          }
        
          function getZombiesByOwner(address _owner) external view returns(uint[]) {
            uint[] memory result = new uint[](ownerZombieCount[_owner]);
            uint counter = 0;
            for (uint i = 0; i < zombies.length; i++) {
              if (zombieToOwner[i] == _owner) {
                result[counter] = i;
                counter++;
              }
            }
            return result;
          }
        
        }
        ```
        

### 좀비 전투

- 예제) 격 기능을 위해 이전의 컨트랙트를 import 하는 새로운 파일/컨트랙트를 생성하면서 우리의 코드를 구성
    1. 우리가 사용할 솔리디티 버전인 `^0.4.19`를 파일의 상단에 선언하게.
    2. `zombiehelper.sol`을 `import` 하게.
    3. `ZombieHelper`를 상속하는 `ZombieBattle`이라는 이름의 새 `contract`를 선언하게. 컨트랙트의 내용은 지금은 비워두게.
- 예제 코드
    
    ```solidity
    pragma solidity ^0.4.19;
    
    import "./zombiehelper.sol";
    
    contract ZombieBattle is ZombieHelper{
      
    }
    ```
    

### 난수****(Random Numbers)****

<aside>
📎 일정 수준의 무작위성을 필요 함. 그럼 솔리디티에서는 어떻게 난수를 발생시키겠는가?
이에 대한 진정한 답은, 자네는 할 수 없다는 것이네. 글쎄, 적어도 안전하게 할 수는 없네.

</aside>

- ****`keccak256`을 통한 난수 생성**
    - 솔리디티에서 난수 생성은 `keccak256` 사용
    - 예시)
        
        ```solidity
        // Generate a random number between 1 and 100:
        uint randNonce = 0;
        uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;
        randNonce++;
        uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100;
        ```
        
        - 예시에서는 `now`의 타임스탬프 값, `msg.sender`, 증가하는 `nonce`(딱 한 번만 사용되는 숫자, 즉 똑같은 입력으로 두 번 이상 동일한 해시 함수를 실행할 수 없게 함)를 받고 있다
        - `keccak`을 사용하여 이 입력들을 임의의 해시 값으로 변환하고, 변환한 해시 값을 `uint`
        로 바꾼 후, `% 100`을 써서 마지막 2자리 숫자만 받음. 이를 통해 0과 99 사이의 완전한 난수를 얻을 수 있음.
- **이 메소드는 정직하지 않은 노드의 공격에 취약**
    - 컴트랙트 함수 실행 단계
        1. 이더리움에서 컨트랙트의 함수를 실행하면 **트랜잭션(transaction)** 으로서 네트워크의 노드 하나 혹은 여러 노드에 실행을 알리게 됨.
        2. 네트워크의 노드들은 여러 개의 트랜잭션을 모으고, **“작업증명”**으로 알려진 계산이 매우 복잡한 수학적 문제를 먼저 풀기 위한 시도를 하게 됨
        3. 해당 트랜잭션 그룹을 그들의 작업 증명(PoW)과 함께`블록`으로 네트워크에 배포하게 됨
        4. 한 노드가 어떤 **PoW**를 풀면, 다른 노드들은 그**PoW**를 풀려는 시도를 멈추고 해당 노드가 낸 트랜잭션 목록이 유효한 것인지 검증
        5. 유효하다면 해당 블록을 받아들이고 다음 블록을 풀기 시작
        
        <aside>
        📎 트랜잭션이 노드에게 실행 신호 → 노드들이 트랜잭션을 모아 트랜잭션 그룹 만듬 → 노드들이 트랜잭션 작업증명(PoW)문제 품 → 네트워크에 트랜잭션 그룹을 PoW와 함께 블록으로 배포 → 한노드가 트랙잭션그룹의 PoW풀면, 다른노드 PoW 실행 멈춤→ 트랜잭션 목록 유효한지 검증 → 다음 블록 해결
        
        </aside>
        
        - 이것이 위 난수 함수를 취약하게 만듬
        - ex) 동전 던지기 컨트랙트를 사용 - 앞면 돈 2배, 뒷면 전부 읽음, 앞귀면 결정을 위 난수 함수 사용 (`random >= 50`은 앞면, `random < 50`은 뒷면)
        - 만약 노드 실행한다면, 오직 나의 노드에만 트랜잭션을 알리고 공유 안할 수 있음. 그후 이기는지 확인하기 위해 동전 던지기 함수 실행. - 만약 진다면 풀고있는 다음 블록에 해당 트랜잭션을 포함하지 않는 것을 선택, 결국 동전 던지기에서 이기고 다음 블록을 풀 때까지 무한대로 반복할 수 있음
- 이더리움에서 안전하게 난수 만들기
    - 이더리움 블록체인 외부의 난수 함수에 접근할 수 있도록 오라클 사용
    - 간단한 난수 생성기로 사용 이유
        - 네트워크 상의 수만개의 이더리움 노드들이 다음 블록을 풀기 위해 경쟁하고 있으니, 내가 다음 블록을 풀 확률은 매우 낮음. 위에서 말한 부당한 방법을 쓰는 것은 많은 시간과 연산자원을 필요로 함 - 하지만 보상이 충분히 크다면, 공격할 만한 가치가 있을 것.
        - 이런 난수 생성은 이더리움 상에서 안전하지 않지만, 실제로는 난수 함수가 즉시 큰 돈이 되지 않는 한, 게임의 사용자들은 게임을 공격할 만한 충분한 자원을 들이지 앙ㄶ음
        - 이게임은 돈이 되는 게 없기 때문에 간단한 난수 생성기로 타협
        
- 예제) 공격에서 완전히 안전하지는 않더라도, 전투의 결과를 결정하는 데에 사용할 수 있는 난수 함수를 구현.
    1. 컨트랙트에 `randNonce`라는 이름의 `uint` 타입 변수를 추가하고, `0`을 대입하게.
    2. `randMod`(random-modulus)라는 이름의 함수를 생성하게. 이 함수는 `_modulus`라는 이름의 `uint` 타입 변수를 받는 `internal` 함수일 것이고, `uint` 타입을 반환(`returns`)할 것이네.
    3. 해당 함수는 먼저 `randNonce`를 하나 증가시킬 것이네(`randNonce++` 문법을 사용하게).
    4. 마지막으로, (한 줄의 코드로)`now`, `msg.sender`, `randNonce`의 `keccak256` 해시 값을 계산하고 `uint`로 변환해야 하네 - 그리고 그 값 `% _modulus`를 한 후 `return`해야 하네(후, 내용이 아주 장황헀군. 잘 이해가 안 된다면, 위에서 우리가 난수를 만들었던 예시를 보게 - 구조가 매우 유사하네).
    - 예제 코드)
        
        ```solidity
        import "./zombiehelper.sol";
        
        contract ZombieBattle is ZombieHelper {
          uint randNonce = 0;
          function randMod(uint _modulus) internal returns(uint) {
            randNonce++;
            return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
          }
        }
        ```
        

### 좀비싸움

- 좀비 전투 진행
    - 자네가 자네 좀비 중 하나를 고르고, 상대방의 좀비를 공격 대상으로 선택하네.
    - 자네가 공격하는 쪽의 좀비라면, 자네는 70%의 승리 확률을 가지네. 방어하는 쪽의 좀비는 30%의 승리 확률을 가질 것이네.
    - 모든 좀비들(공격, 방어 모두)은 전투 결과에 따라 증가하는 `winCount`와 `lossCount`를 가질 것이네.
    - 공격하는 쪽의 좀비가 이기면, 좀비의 레벨이 오르고 새로운 좀비가 생기네.
    - 좀비가 지면, 아무것도 일어나지 않네(좀비의 `lossCount`가 증가하는 것 빼고 말이야).
    - 좀비가 이기든 지든, 공격하는 쪽 좀비의 재사용 대기시간이 활성화될 것이네.
- 예제)
    1. 컨트랙트에 `attackVictoryProbability`라는 이름의 `uint` 변수를 추가하고, 여기에 `70`을 대입하게.
    2. `attack`이라는 이름의 함수를 생성하게. 이 함수는 두 개의 매개변수를 받을 것이네: `_zombieId`(`uint`)와 `_targetId`(`uint`)이네. 이 함수는 `external`이어야 하네.
    - 예제 코드
        
        ```solidity
        import "./zombiehelper.sol";
        
        contract ZombieBattle is ZombieHelper {
          uint randNonce = 0;
          // 여기에 attackVictoryProbability를 만들게
          uint attackVictoryProbability = 70;
        
          function randMod(uint _modulus) internal returns(uint) {
            randNonce++;
            return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
          }
        
          // 여기에 새로운 함수를 만들게
          function attack(uint _zombieId, uint _targetId) external {
        
          }
        }
        ```
        

### 공통 로직 구조 개선하기

- 사용자가 공격에 사용하는 좀비를 실제로 소유하고 있다는 것을 확실히 하고 싶음. 만약 다른 사람의 좀비를 사용해서 공격할 수 있다면 보안에 문제가 되는 부분.
- 함수를 호출하는 사람이 그가 사용한 `_zombieId`의 소유자인지 확인할 방법
    
    ```solidity
    require(msg.sender == zombieToOwner[_zombieId]);
    ```
    
    - 동일한 내용을 여러 번 사용하고 있으니, 코드를 정리하고 반복을 피할 수 있도록 이 내용을 이것만의 `modifier`로 옮김
- 예제) `zombiefeeding.sol`을 다시 해봄. 확인 부분을 그 부분만의 `modifier`로 만들어 구조를 개선
    1. `modifier`를 `ownerOf`라는 이름으로 만들게. 이 제어자는 `_zombieId`(`uint`)를 1개의 인수로 받을 것이네.
        
        제어자 내용에서는 `msg.sender`와 `zombieToOwner[_zombieId]`가 같은지 `require`로 확인하고, 함수를 실행해야 하네. 제어자의 문법이 기억이 나지 않는다면 `zombiehelper.sol`을 참고하면 되네.
        
    2. `feedAndMultiply`의 함수 정의 부분을 `ownerOf` 제어자를 사용하도록 바꾸게.
    3. 이제 `modifier`를 사용하게 됐으니, `require(msg.sender == zombieToOwner[_zombieId]);` 줄을 지워도 되네.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefactory.sol";
        
        contract KittyInterface {
          function getKitty(uint256 _id) external view returns (
            bool isGestating,
            bool isReady,
            uint256 cooldownIndex,
            uint256 nextActionAt,
            uint256 siringWithId,
            uint256 birthTime,
            uint256 matronId,
            uint256 sireId,
            uint256 generation,
            uint256 genes
          );
        }
        
        contract ZombieFeeding is ZombieFactory {
        
          KittyInterface kittyContract;
        
          // 1. 여기에 제어자를 생성하게
          modifier ownerOf(uint _zombieId){
            require(msg.sender == zombieToOwner[_zombieId]);
            _;
          }
        
          function setKittyContractAddress(address _address) external onlyOwner {
            kittyContract = KittyInterface(_address);
          }
        
          function _triggerCooldown(Zombie storage _zombie) internal {
            _zombie.readyTime = uint32(now + cooldownTime);
          }
        
          function _isReady(Zombie storage _zombie) internal view returns (bool) {
              return (_zombie.readyTime <= now);
          }
        
          // 2. 함수 정의 부분에 제어자를 추가하게:
          function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal ownerOf(_zombieId) {
            // 3. 이 줄을 지우게
            Zombie storage myZombie = zombies[_zombieId];
            require(_isReady(myZombie));
            _targetDna = _targetDna % dnaModulus;
            uint newDna = (myZombie.dna + _targetDna) / 2;
            if (keccak256(_species) == keccak256("kitty")) {
              newDna = newDna - newDna % 100 + 99;
            }
            _createZombie("NoName", newDna);
            _triggerCooldown(myZombie);
          }
        
          function feedOnKitty(uint _zombieId, uint _kittyId) public {
            uint kittyDna;
            (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
            feedAndMultiply(_zombieId, kittyDna, "kitty");
          }
        }
        ```
        
- 구조 더 개선하기
    1. `changeName()`를 `ownerOf`를 사용하도록 변경하게.
    2. `changeDna()`를 `ownerOf`를 사용하도록 변경하게.
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefeeding.sol";
        
        contract ZombieHelper is ZombieFeeding {
        
          uint levelUpFee = 0.001 ether;
        
          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }
        
          function withdraw() external onlyOwner {
            owner.transfer(this.balance);
          }
        
          function setLevelUpFee(uint _fee) external onlyOwner {
            levelUpFee = _fee;
          }
        
          // 1. 이 함수를 `ownerOf`를 사용하도록 변경하게:
          function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) ownerOf(_zombieId) {
            zombies[_zombieId].name = _newName;
          }
        
          // 2. 이 함수에도 똑같이 적용하게:
          function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) ownerOf(_zombieId) {
            zombies[_zombieId].dna = _newDna;
          }
        
          function getZombiesByOwner(address _owner) external view returns(uint[]) {
            uint[] memory result = new uint[](ownerZombieCount[_owner]);
            uint counter = 0;
            for (uint i = 0; i < zombies.length; i++) {
              if (zombieToOwner[i] == _owner) {
                result[counter] = i;
                counter++;
              }
            }
            return result;
          }
        
        }
        ```
        

### 공격으로 돌아가자

- `attack`함수를 계속 정의
- 예제)
    1. 함수를 호출하는 사람이 `_zombieId`를 소유하고 있는지 확인하기 위해 `attack` 함수에 `ownerOf` 제어자를 추가하게.
    2. 우리 함수에서 처음으로 해야 할 것은 두 좀비의 `storage` 포인터를 얻어서 그들과 상호작용 하기 쉽도록 하는 것이네.
        
        a. `Zombie storage`를 `myZombie`라는 이름으로 선언하고, 여기에 `zombies[_zombieId]`를 대입하게.
        
        b. `Zombie storage`를 `enemyZombie`라는 이름으로 선언하고, 여기에 `zombies[_targetId]`를 대입하게.
        
    3. 우린 전투의 결과를 결정하기 위해 0과 99 사이의 난수를 사용할 것이네. 그러니 `uint`를 `rand`라는 이름으로 선언하고, 여기에 `randMod` 함수에 `100`을 인수로 사용한 값을 대입하게.
    - 예제 코드
        
        ```solidity
        import "./zombiehelper.sol";
        
        contract ZombieBattle is ZombieHelper {
          uint randNonce = 0;
          uint attackVictoryProbability = 70;
        
          function randMod(uint _modulus) internal returns(uint) {
            randNonce++;
            return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
          }
        
          // 1. 여기에 제어자를 추가하게
          function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {
            // 2. 여기서 함수 정의를 시작하게
            Zombie storage myZombie = zombies[_zombieId];
            Zombie storage enemyZombie = zombies[_targetId];
            uint rand = randMod(100);
          }
        }
        ```
        

### 좀비 승리와 패배

- 좀비들이 얼마나 많이 이기고 졌는지를 추적. 이렇게 하면 게임 상에서 "좀비 순위표"를 유지
    - DApp에서 다양한 방식으로 이 데이터를 저장할 수 있음 - 개별적인 매핑으로, 순위표 구조체로, 혹은 `Zombie` 구조체 자체에 넣을 수도 있음
    - `Zombie` 구조체에 상태를 저장하도록 하고, 이들을 `winCount`와 `lossCount`로 이름짓도록 함.
- 예제)
    1. `Zombie` 구조체가 2개의 속성을 더 가지도록 수정하게:
        
        a. `winCount`, `uint16` 타입
        
        b. `lossCount`, 역시 `uint16` 타입
        
        > 참고: 기억하게, 구조체 안에서 uint들을 압축(pack)할 수 있으니, 우리가 다룰 수 있는 가장 작은 uint 타입을 사용하는 것이 좋을 것이네. uint8은 너무 작을 것이네. 2^8 = 256이기 때문이지 - 만약 우리 좀비가 하루에 한 번씩 공격한다면, 일 년 안에 데이터 크기가 넘쳐버릴 수 있을 것이네. 하지만 2^16은 65536이네 - 그러니 한 사용자가 매일 179년 동안 이기거나 지지 않는다면, 이걸로 안전할 것이네.
        > 
    2. 이제 우리는 `Zombie` 구조체에 새로운 속성들을 가지게 되었으니, `_createZombie()`의 함수 정의 부분을 수정해야 할 필요가 있네.
        
        각각의 새로운 좀비가 `0`승 `0`패를 가지고 생성될 수 있도록 좀비 생성의 정의 부분을 변경하게.
        
    - 예제 코드
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./ownable.sol";
        
        contract ZombieFactory is Ownable {
        
            event NewZombie(uint zombieId, string name, uint dna);
        
            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;
            uint cooldownTime = 1 days;
        
            struct Zombie {
              string name;
              uint dna;
              uint32 level;
              uint32 readyTime;
              // 1. 여기에 새로운 속성을 추가하게
              uint16 winCount;
              uint16 lossCount;
            }
        
            Zombie[] public zombies;
        
            mapping (uint => address) public zombieToOwner;
            mapping (address => uint) ownerZombieCount;
        
            function _createZombie(string _name, uint _dna) internal {
                // 2. 여기서 새로운 좀비의 생성을 수정하게:
                uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;
                zombieToOwner[id] = msg.sender;
                ownerZombieCount[msg.sender]++;
                NewZombie(id, _name, _dna);
            }
        
            function _generateRandomDna(string _str) private view returns (uint) {
                uint rand = uint(keccak256(_str));
                return rand % dnaModulus;
            }
        
            function createRandomZombie(string _name) public {
                require(ownerZombieCount[msg.sender] == 0);
                uint randDna = _generateRandomDna(_name);
                randDna = randDna - randDna % 100;
                _createZombie(_name, randDna);
            }
        
        }
        ```
        

### 좀비 승리

- 0부터 100까지의 난수를 계산. 그 숫자를 누가 싸움에서 이길지 결정하는 데에 사용하고, 그에 따라 상태를 업데이트
- 예제)
    1. `rand`가 `attackVictoryProbability`와 ***같거나 더 작은지*** 확인하는 `if` 문장을 만들게.
    2. 만약 이 조건이 참이라면, 우리 좀비가 이기게 되네! 그렇다면:
        
        a. `myZombie`의 `winCount`를 증가시키게.
        
        b. `myZombie`의 `level`을 증가시키게. (레벨업이다!!!!!!!)
        
        c. `enemyZombie`의 `lossCount`를 증가시키게. (이 패배자!!!!!!! 😫 😫 😫)
        
        d. `feedAndMultiply` 함수를 실행하게. 실행을 위한 문법을 보려면 `zombiefeeding.sol`을 확인하게. 3번째 인수(`_species`)로는 `"zombie"`라는 문자열을 전달하게(이건 지금 이 순간에는 실제로 아무 것도 하지 않지만, 이후에 우리가 원한다면 좀비 기반의 좀비를 만들어내는 부가적인 기능을 추가할 수도 있을 것이네).
        
        - 예제 코드
            
            ```solidity
            import "./zombiehelper.sol";
            
            contract ZombieBattle is ZombieHelper {
              uint randNonce = 0;
              uint attackVictoryProbability = 70;
            
              function randMod(uint _modulus) internal returns(uint) {
                randNonce++;
                return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
              }
            
              function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {
                Zombie storage myZombie = zombies[_zombieId];
                Zombie storage enemyZombie = zombies[_targetId];
                uint rand = randMod(100);
                // 여기서 시작하게
                if (rand <= attackVictoryProbability) {
                  myZombie.winCount++;
                  myZombie.level++;
                  enemyZombie.lossCount++;
                  feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");
                }
              }
            }
            ```
            

### 좀비 패배

- 좀비의 `lossCount`에 그들의 패배를 기록하고, 다시 공격하기 전에 하루를 기다려야만 하도록 그들의 재사용 대기시간이 활성화 함.
- 예제)
    1. `else` 문장을 추가하게. 만약 우리의 좀비가 진다면:
        
        a. `myZombie`의 `lossCount`를 증가시키게.
        
        b. `enemyZombie`의 `winCount`를 증가시키게.
        
    2. else 문장의 밖에서, `myZombie`에 대해 `_triggerCooldown` 함수를 실행하게. 이러한 방법으로 해당 좀비는 하루에 한 번만 공격할 수 있네.
    - 예제 코드
        
        ```solidity
        import "./zombiehelper.sol";
        
        contract ZombieBattle is ZombieHelper {
          uint randNonce = 0;
          uint attackVictoryProbability = 70;
        
          function randMod(uint _modulus) internal returns(uint) {
            randNonce++;
            return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
          }
        
          function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {
            Zombie storage myZombie = zombies[_zombieId];
            Zombie storage enemyZombie = zombies[_targetId];
            uint rand = randMod(100);
            if (rand <= attackVictoryProbability) {
              myZombie.winCount++;
              myZombie.level++;
              enemyZombie.lossCount++;
              feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");
            } // 여기서 시작하게
            else{
              myZombie.lossCount++;
              enemyZombie.winCount++;
            }
            _triggerCooldown(myZombie);
          }
        }
        ```