# 4.ì¢€ë¹„ ì „íˆ¬ ì‹œìŠ¤í…œ

### Payable

- í•¨ìˆ˜ ì œì–´ì ì •ë¦¬
    1. ìš°ë¦° í•¨ìˆ˜ê°€ ì–¸ì œ, ì–´ë””ì„œ í˜¸ì¶œë  ìˆ˜ ìˆëŠ”ì§€ ì œì–´í•˜ëŠ” ì ‘ê·¼ ì œì–´ì(visibility modifier)ë¥¼ ì•Œê²Œ ë˜ì—ˆìŒ:Â `private`ì€ ì»¨íŠ¸ë™íŠ¸ ë‚´ë¶€ì˜ ë‹¤ë¥¸ í•¨ìˆ˜ë“¤ì—ì„œë§Œ í˜¸ì¶œë  ìˆ˜ ìˆìŒì„ ì˜ë¯¸.Â 
    `internal`ì€Â `private`ê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ, í•´ë‹¹ ì»¨íŠ¸ë™íŠ¸ë¥¼ ìƒì†í•˜ëŠ” ì»¨íŠ¸ë™íŠ¸ì—ì„œë„ í˜¸ì¶œë  ìˆ˜ ìˆìŒ.Â `external`ì€ ì˜¤ì§ ì»¨íŠ¸ë™íŠ¸ ì™¸ë¶€ì—ì„œë§Œ í˜¸ì¶œë  ìˆ˜ ìˆìŒ. ë§ˆì§€ë§‰ìœ¼ë¡œÂ `public`ì€ ë‚´ì™¸ë¶€ ëª¨ë‘ì—ì„œ, ì–´ë””ì„œë“  í˜¸ì¶œë  ìˆ˜ ìˆìŒ.
    2. ìƒíƒœ ì œì–´ì(state modifier): ì´ ì œì–´ìëŠ” ë¸”ë¡ì²´ì¸ê³¼ ìƒí˜¸ì‘ìš© í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ ì•Œë ¤ì¤Œ:
    Â `view`ëŠ” í•´ë‹¹ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•´ë„ ì–´ë–¤ ë°ì´í„°ë„ ì €ì¥/ë³€ê²½ë˜ì§€ ì•ŠìŒì„ ì•Œë ¤ì¤Œ.Â `pure`ëŠ” í•´ë‹¹ í•¨ìˆ˜ê°€ ì–´ë–¤ ë°ì´í„°ë„ ë¸”ë¡ì²´ì¸ì— ì €ì¥í•˜ì§€ ì•Šì„ ë¿ë§Œ ì•„ë‹ˆë¼, ë¸”ë¡ì²´ì¸ìœ¼ë¡œë¶€í„° ì–´ë–¤ ë°ì´í„°ë„ ì½ì§€ ì•ŠìŒì„ ì•Œë ¤ì¤Œ. ì´ë“¤ ëª¨ë‘ëŠ” ì»¨íŠ¸ë™íŠ¸ ì™¸ë¶€ì—ì„œ ë¶ˆë ¸ì„ ë•Œ ê°€ìŠ¤ë¥¼ ì „í˜€ ì†Œëª¨í•˜ì§€ ì•ŠìŒ(í•˜ì§€ë§Œ ë‹¤ë¥¸ í•¨ìˆ˜ì— ì˜í•´ ë‚´ë¶€ì ìœ¼ë¡œ í˜¸ì¶œëì„ ê²½ìš°ì—ëŠ” ê°€ìŠ¤ë¥¼ ì†Œëª¨).
    3. ì‚¬ìš©ì ì •ì˜Â `ì œì–´ì` : ì˜ˆë¥¼ ë“¤ìë©´Â `onlyOwner`ì™€Â `aboveLevel`Â ê°™ì€ ê²ƒ. ì´ëŸ° ì œì–´ìë¥¼ ì‚¬ìš©í•´ì„œ ìš°ë¦° í•¨ìˆ˜ì— ì´ ì œì–´ìë“¤ì´ ì–´ë–»ê²Œ ì˜í–¥ì„ ì¤„ì§€ë¥¼ ê²°ì •í•˜ëŠ” ìš°ë¦¬ë§Œì˜ ë…¼ë¦¬ë¥¼ êµ¬ì„±í•  ìˆ˜ ìˆìŒ.
    - ì œì–´ì œë“¤ì„ í•¨ìˆ˜ í•˜ë‚˜ì— ì‚¬ìš©
    
    ```solidity
    function test() external view onlyOwner anotherModifier { /* ... */ }
    ```
    
- payable ì œì–´ì
    - `payable`í•¨ìˆ˜ : ì´ë”ë¥¼ ë°›ì„ ìˆ˜ ìˆëŠ” íŠ¹ë³„í•œ í•¨ìˆ˜ ìœ í˜•
        - ì¼ë°˜ì ì¸ ì›¹ ì„œë²„ì—ì„œ API í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•  ë•Œì—ëŠ”,í•¨ìˆ˜ í˜¸ì¶œì„ í†µí•´ì„œ US ë‹¬ëŸ¬ë¥¼ ë³´ë‚¼ ìˆ˜ ì—†ìŒ
        - ì´ë”ë¦¬ì›€ì—ì„œëŠ”, ëˆ(_ì´ë”_), ë°ì´í„°(*transaction payload*), ê·¸ë¦¬ê³  ì»¨íŠ¸ë™íŠ¸ ì½”ë“œ ìì²´ 
        ëª¨ë‘ ì´ë”ë¦¬ì›€ ìœ„ì— ì¡´ì¬í•˜ê¸° ë•Œë¬¸ì—, ìë„¤ê°€ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ëŠ”Â **ë™ì‹œì—** ì»¨íŠ¸ë™íŠ¸ì— ëˆì„ ì§€ë¶ˆí•˜ëŠ” ê²ƒì´ ê°€ëŠ¥
    - ì˜ˆì‹œ
        
        ```solidity
        contract OnlineStore {
          function buySomething() external payable {
            // í•¨ìˆ˜ ì‹¤í–‰ì— 0.001ì´ë”ê°€ ë³´ë‚´ì¡ŒëŠ”ì§€ í™•ì‹¤íˆ í•˜ê¸° ìœ„í•´ í™•ì¸:
            require(msg.value == 0.001 ether);
            // ë³´ë‚´ì¡Œë‹¤ë©´, í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ ìì—ê²Œ ë””ì§€í„¸ ì•„ì´í…œì„ ì „ë‹¬í•˜ê¸° ìœ„í•œ ë‚´ìš© êµ¬ì„±:
            transferThing(msg.sender);
          }
        }
        ```
        
        - `msg.value`
        ëŠ” ì»¨íŠ¸ë™íŠ¸ë¡œ ì´ë”ê°€ ì–¼ë§ˆë‚˜ ë³´ë‚´ì¡ŒëŠ”ì§€ í™•ì¸í•˜ëŠ” ë°©ë²•ì´ê³ ,Â `ether`ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ í¬í•¨ëœ ë‹¨ìœ„
    - ëˆ„êµ°ê°€ web3.js(DAppì˜ ìë°”ìŠ¤í¬ë¦½íŠ¸ í”„ë¡ íŠ¸ì—”ë“œ)ì—ì„œ ë‹¤ìŒê³¼ ê°™ì´ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•  ë•Œ ë°œìƒ
        
        ```solidity
        // `OnlineStore`ëŠ” ìë„¤ì˜ ì´ë”ë¦¬ì›€ ìƒì˜ ì»¨íŠ¸ë™íŠ¸ë¥¼ ê°€ë¦¬í‚¨ë‹¤ê³  ê°€ì •í•˜ë„¤:
        OnlineStore.buySomething({from: web3.eth.defaultAccount, value: web3.utils.toWei(0.001)})
        ```
        
        - `value`Â í•„ë“œë¥¼ ì£¼ëª©í•˜ë©´, ìë°”ìŠ¤í¬ë¦½íŠ¸ í•¨ìˆ˜ í˜¸ì¶œì—ì„œ ì´ í•„ë“œë¥¼ í†µí•´Â `ether`ë¥¼ ì–¼ë§ˆë‚˜ ë³´ë‚¼ì§€ ê²°ì •. íŠ¸ëœì­ì…˜ì„ ë´‰íˆ¬ë¡œ ìƒê°í•˜ê³ , í•¨ìˆ˜ í˜¸ì¶œì— ì „ë‹¬í•˜ëŠ” ë§¤ê°œ ë³€ìˆ˜ë¥¼ ì¨ë„£ì€ í¸ì§€ì˜ ë‚´ìš©ì´ë¼ ìƒê°í•œë‹¤ë©´,Â `value`ëŠ” ë´‰íˆ¬ ì•ˆì— í˜„ê¸ˆì„ ë„£ëŠ” ê²ƒê³¼ ê°™ìŒ. 
        - í¸ì§€ì™€ ëˆì´ ëª¨ë‘ ìˆ˜ë ¹ì¸ì—ê²Œ ì „ë‹¬.
            
            > *ì°¸ê³ : ë§Œì•½ í•¨ìˆ˜ê°€Â `payable`ë¡œ í‘œì‹œë˜ì§€ ì•Šì•˜ëŠ”ë° ìë„¤ê°€ ìœ„ì—ì„œ ë³¸ ê²ƒì²˜ëŸ¼ ì´ë”ë¥¼ ë³´ë‚´ë ¤ í•œë‹¤ë©´, í•¨ìˆ˜ì—ì„œ ìë„¤ì˜ íŠ¸ëœì­ì…˜ì„ ê±°ë¶€í•  ê²ƒ.*
            > 
- ì˜ˆì œ) ì¢€ë¹„ì˜ ë ˆë²¨ì—…ì„ ìœ„í•´ ì‚¬ìš©ìë“¤ì´ ETHë¥¼ ì§€ë¶ˆí•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì´ ìˆë‹¤ê³  ê°€ì •. ETHëŠ”  ì†Œìœ í•œ ì»¨íŠ¸ë™íŠ¸ì— ì €ì¥ë  ê²ƒ - ì´ëŠ” ê²Œì„ì„ í†µí•´ ìë„¤ê°€ ëˆì„ ë²Œ ìˆ˜ ìˆëŠ” ê°„ë‹¨í•œ ì˜ˆì‹œ
    1. `uint`Â íƒ€ì…ì˜Â `levelUpFee`Â ë³€ìˆ˜ë¥¼ ì •ì˜í•˜ê³ , ì—¬ê¸°ì—Â `0.001 ether`ë¥¼ ëŒ€ì…í•˜ê²Œ.
    2. `levelUp`ì´ë¼ëŠ” í•¨ìˆ˜ë¥¼ ìƒì„±í•˜ê²Œ. ì´ í•¨ìˆ˜ëŠ”Â `_zombieId`ë¼ëŠ”Â `uint`Â íƒ€ì…ì˜ ë§¤ê°œë³€ìˆ˜ í•˜ë‚˜ë¥¼ ë°›ì„ ê²ƒì´ë„¤. í•¨ìˆ˜ëŠ”Â `external`ì´ë©´ì„œÂ `payable`ì´ì–´ì•¼ í•˜ë„¤.
    3. ì´ í•¨ìˆ˜ëŠ” ë¨¼ì €Â `msg.value`ê°€Â `levelUpFee`ì™€ ê°™ì€ì§€Â `require`ë¡œ í™•ì¸í•´ì•¼ í•˜ë„¤.
    4. ê·¸ë¦¬ê³ ì„œ ì¢€ë¹„ì˜Â `level`ì„ ì¦ê°€ì‹œì¼œì•¼ í•˜ë„¤:Â `zombies[_zombieId].level++`. 
    - ì˜ˆì œ ì½”ë“œ
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefeeding.sol";
        
        contract ZombieHelper is ZombieFeeding {
        
          // 1. ì—¬ê¸°ì— levelUpFeeë¥¼ ì •ì˜í•˜ê²Œ
          uint levelUpFee = 0.001 ether;
        
          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }
        
          // 2. ì—¬ê¸°ì— levelUp í•¨ìˆ˜ë¥¼ ì‚½ì…í•˜ê²Œ
          function levelUp(uint _zombieId) external payable {
            require(msg.value == levelUpFee);
            zombies[_zombieId].level++;
          }
        
          function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].name = _newName;
          }
        
          function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].dna = _newDna;
          }
        
          function getZombiesByOwner(address _owner) external view returns(uint[]) {
            uint[] memory result = new uint[](ownerZombieCount[_owner]);
            uint counter = 0;
            for (uint i = 0; i < zombies.length; i++) {
              if (zombieToOwner[i] == _owner) {
                result[counter] = i;
                counter++;
              }
            }
            return result;
          }
        
        }
        ```
        

### ì¶œê¸ˆ

- ì»¨íŠ¸ë™íŠ¸ì—ì„œ ì´ë”ë¥¼ ì¸ì¶œí•˜ëŠ” í•¨ìˆ˜
    
    ```solidity
    contract GetPaid is Ownable {
      function withdraw() external onlyOwner {
        owner.transfer(this.balance);
      }
    }
    ```
    
    - `transfer`Â í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ì´ë”ë¥¼ íŠ¹ì • ì£¼ì†Œë¡œ ì „ë‹¬í•  ìˆ˜ ìˆìŒ.
    - `this.balance`ëŠ” ì»¨íŠ¸ë™íŠ¸ì— ì €ì¥ë¼ìˆëŠ” ì „ì²´ ì”ì•¡ì„ ë°˜í™˜.
        - 100ëª…ì˜ ì‚¬ìš©ìê°€ ìš°ë¦¬ì˜ ì»¨íŠ¸ë™íŠ¸ì— 1ì´ë”ë¥¼ ì§€ë¶ˆí–ˆë‹¤ë©´,Â `this.balance`ëŠ” 100ì´ë”ê°€ ë  ê²ƒ.
    - `transfer`Â í•¨ìˆ˜ë¥¼ ì¨ì„œ íŠ¹ì •í•œ ì´ë”ë¦¬ì›€ ì£¼ì†Œì— ëˆì„ ë³´ë‚¼ ìˆ˜ ìˆìŒ.
        - ì˜ˆë¥¼ ë“¤ì–´, ë§Œì•½ ëˆ„êµ°ê°€ í•œ ì•„ì´í…œì— ëŒ€í•´ ì´ˆê³¼ ì§€ë¶ˆì„ í–ˆë‹¤ë©´, ì´ë”ë¥¼Â `msg.sender`
        ë¡œ ë˜ëŒë ¤ì£¼ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“¤ ìˆ˜ë„ ìˆìŒ.
        
        ```solidity
        uint itemFee = 0.001 ether;
        msg.sender.transfer(msg.value - itemFee);
        ```
        
    - êµ¬ë§¤ìì™€ íŒë§¤ìê°€ ì¡´ì¬í•˜ëŠ” ì»¨íŠ¸ë™íŠ¸ì—ì„œ, íŒë§¤ìì˜ ì£¼ì†Œë¥¼ storageì— ì €ì¥í•˜ê³ , ëˆ„êµ°ê°€ íŒë§¤ìì˜ ì•„ì´í…œì„ êµ¬ë§¤í•˜ë©´ êµ¬ë§¤ìë¡œë¶€í„° ë°›ì€ ìš”ê¸ˆì„ ê·¸ì—ê²Œ ì „ë‹¬í•  ìˆ˜ë„ ìˆìŒ
        
        ```solidity
        seller.transfer(msg.value).
        ```
        
- ì˜ˆì œ)
    1. ìš°ë¦¬ ì»¨íŠ¸ë™íŠ¸ì—Â `withdraw`Â í•¨ìˆ˜ë¥¼ ìƒì„±í•˜ê²Œ. ì´ í•¨ìˆ˜ëŠ” ìœ„ì—ì„œ ë³¸Â `GetPaid`Â ì˜ˆì œì™€ ë™ì¼í•´ì•¼ í•˜ë„¤.
    2. ì´ë”ì˜ ê°€ê²©ì€ ê³¼ê±°ì— ë¹„í•´ 10ë°° ì´ìƒ ë›°ì—ˆë„¤. ê·¸ëŸ¬ë‹ˆ ì§€ê¸ˆ ì´ ê¸€ì„ ì“°ëŠ” ì‹œì ì—ì„œëŠ” 0.001ì´ë”ê°€ 1ë‹¬ëŸ¬ ì •ë„ ë˜ì§€ë§Œ, ë§Œì•½ ì´ê²Œ ë‹¤ì‹œ 10ë°°ê°€ ë˜ë©´ 0.001 ETHëŠ” 10ë‹¬ëŸ¬ê°€ ë  ê²ƒì´ê³  ìš°ë¦¬ì˜ ê²Œì„ì€ ë” ë¹„ì‹¸ì§ˆ ê²ƒì´ë„¤.
    ê·¸ëŸ¬ë‹ˆ ì»¨íŠ¸ë™íŠ¸ì˜ ì†Œìœ ìë¡œì„œ ìš°ë¦¬ê°€Â `levelUpFee`ë¥¼ ì„¤ì •í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“œëŠ” ê²ƒì´ ì¢‹ê² ì§€.
        1. `setLevelUpFee`ë¼ëŠ” ì´ë¦„ì˜,Â `uint _fee`ë¥¼ í•˜ë‚˜ì˜ ì¸ìë¡œ ë°›ê³ Â `externalì´`ë©°Â `onlyOwner`Â ì œì–´ìë¥¼ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜ë¥¼ ìƒì„±í•˜ê²Œ.
        2. ì´ í•¨ìˆ˜ëŠ”Â `levelUpFee`ë¥¼Â `_fee`ë¡œ ì„¤ì •í•´ì•¼ í•˜ë„¤.
    - ì˜ˆì œ ì½”ë“œ
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefeeding.sol";
        
        contract ZombieHelper is ZombieFeeding {
        
          uint levelUpFee = 0.001 ether;
        
          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }
        
          // 1. ì—¬ê¸°ì— withdraw í•¨ìˆ˜ë¥¼ ìƒì„±í•˜ê²Œ
          function withdraw() external onlyOwner {
            owner.transfer(this.balance);
          }
        
          // 2. ì—¬ê¸°ì— setLevelUpFeeë¥¼ ìƒì„±í•˜ê²Œ
          function setLevelUpFee(uint _fee) external onlyOwner {
            levelUpFee = _fee;
          } 
        
          function levelUp(uint _zombieId) external payable {
            require(msg.value == levelUpFee);
            zombies[_zombieId].level++;
          }
        
          function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].name = _newName;
          }
        
          function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            zombies[_zombieId].dna = _newDna;
          }
        
          function getZombiesByOwner(address _owner) external view returns(uint[]) {
            uint[] memory result = new uint[](ownerZombieCount[_owner]);
            uint counter = 0;
            for (uint i = 0; i < zombies.length; i++) {
              if (zombieToOwner[i] == _owner) {
                result[counter] = i;
                counter++;
              }
            }
            return result;
          }
        
        }
        ```
        

### ì¢€ë¹„ ì „íˆ¬

- ì˜ˆì œ) ê²© ê¸°ëŠ¥ì„ ìœ„í•´ ì´ì „ì˜ ì»¨íŠ¸ë™íŠ¸ë¥¼ import í•˜ëŠ” ìƒˆë¡œìš´ íŒŒì¼/ì»¨íŠ¸ë™íŠ¸ë¥¼ ìƒì„±í•˜ë©´ì„œ ìš°ë¦¬ì˜ ì½”ë“œë¥¼ êµ¬ì„±
    1. ìš°ë¦¬ê°€ ì‚¬ìš©í•  ì†”ë¦¬ë””í‹° ë²„ì „ì¸Â `^0.4.19`ë¥¼ íŒŒì¼ì˜ ìƒë‹¨ì— ì„ ì–¸í•˜ê²Œ.
    2. `zombiehelper.sol`ì„Â `import`Â í•˜ê²Œ.
    3. `ZombieHelper`ë¥¼ ìƒì†í•˜ëŠ”Â `ZombieBattle`ì´ë¼ëŠ” ì´ë¦„ì˜ ìƒˆÂ `contract`ë¥¼ ì„ ì–¸í•˜ê²Œ. ì»¨íŠ¸ë™íŠ¸ì˜ ë‚´ìš©ì€ ì§€ê¸ˆì€ ë¹„ì›Œë‘ê²Œ.
- ì˜ˆì œ ì½”ë“œ
    
    ```solidity
    pragma solidity ^0.4.19;
    
    import "./zombiehelper.sol";
    
    contract ZombieBattle is ZombieHelper{
      
    }
    ```
    

### ë‚œìˆ˜****(Random Numbers)****

<aside>
ğŸ“ ì¼ì • ìˆ˜ì¤€ì˜ ë¬´ì‘ìœ„ì„±ì„ í•„ìš” í•¨. ê·¸ëŸ¼ ì†”ë¦¬ë””í‹°ì—ì„œëŠ” ì–´ë–»ê²Œ ë‚œìˆ˜ë¥¼ ë°œìƒì‹œí‚¤ê² ëŠ”ê°€?
ì´ì— ëŒ€í•œ ì§„ì •í•œ ë‹µì€, ìë„¤ëŠ” í•  ìˆ˜ ì—†ë‹¤ëŠ” ê²ƒì´ë„¤. ê¸€ì„, ì ì–´ë„ ì•ˆì „í•˜ê²Œ í•  ìˆ˜ëŠ” ì—†ë„¤.

</aside>

- ****`keccak256`ì„ í†µí•œ ë‚œìˆ˜ ìƒì„±**
    - ì†”ë¦¬ë””í‹°ì—ì„œ ë‚œìˆ˜ ìƒì„±ì€ `keccak256` ì‚¬ìš©
    - ì˜ˆì‹œ)
        
        ```solidity
        // Generate a random number between 1 and 100:
        uint randNonce = 0;
        uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;
        randNonce++;
        uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100;
        ```
        
        - ì˜ˆì‹œì—ì„œëŠ”Â `now`ì˜ íƒ€ì„ìŠ¤íƒ¬í”„ ê°’,Â `msg.sender`, ì¦ê°€í•˜ëŠ”Â `nonce`(ë”± í•œ ë²ˆë§Œ ì‚¬ìš©ë˜ëŠ” ìˆ«ì, ì¦‰ ë˜‘ê°™ì€ ì…ë ¥ìœ¼ë¡œ ë‘ ë²ˆ ì´ìƒ ë™ì¼í•œ í•´ì‹œ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•  ìˆ˜ ì—†ê²Œ í•¨)ë¥¼ ë°›ê³  ìˆë‹¤
        - `keccak`ì„ ì‚¬ìš©í•˜ì—¬ ì´ ì…ë ¥ë“¤ì„ ì„ì˜ì˜ í•´ì‹œ ê°’ìœ¼ë¡œ ë³€í™˜í•˜ê³ , ë³€í™˜í•œ í•´ì‹œ ê°’ì„Â `uint`
        ë¡œ ë°”ê¾¼ í›„,Â `% 100`ì„ ì¨ì„œ ë§ˆì§€ë§‰ 2ìë¦¬ ìˆ«ìë§Œ ë°›ìŒ. ì´ë¥¼ í†µí•´ 0ê³¼ 99 ì‚¬ì´ì˜ ì™„ì „í•œ ë‚œìˆ˜ë¥¼ ì–»ì„ ìˆ˜ ìˆìŒ.
- **ì´ ë©”ì†Œë“œëŠ” ì •ì§í•˜ì§€ ì•Šì€ ë…¸ë“œì˜ ê³µê²©ì— ì·¨ì•½**
    - ì»´íŠ¸ë™íŠ¸ í•¨ìˆ˜ ì‹¤í–‰ ë‹¨ê³„
        1. ì´ë”ë¦¬ì›€ì—ì„œ ì»¨íŠ¸ë™íŠ¸ì˜ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ë©´ **íŠ¸ëœì­ì…˜(transaction)** ìœ¼ë¡œì„œ ë„¤íŠ¸ì›Œí¬ì˜ ë…¸ë“œ í•˜ë‚˜ í˜¹ì€ ì—¬ëŸ¬ ë…¸ë“œì— ì‹¤í–‰ì„ ì•Œë¦¬ê²Œ ë¨.
        2. ë„¤íŠ¸ì›Œí¬ì˜ ë…¸ë“œë“¤ì€ ì—¬ëŸ¬ ê°œì˜ íŠ¸ëœì­ì…˜ì„ ëª¨ìœ¼ê³ , **â€œì‘ì—…ì¦ëª…â€**ìœ¼ë¡œ ì•Œë ¤ì§„ ê³„ì‚°ì´ ë§¤ìš° ë³µì¡í•œ ìˆ˜í•™ì  ë¬¸ì œë¥¼ ë¨¼ì € í’€ê¸° ìœ„í•œ ì‹œë„ë¥¼ í•˜ê²Œ ë¨
        3. í•´ë‹¹ íŠ¸ëœì­ì…˜ ê·¸ë£¹ì„ ê·¸ë“¤ì˜ ì‘ì—… ì¦ëª…(PoW)ê³¼ í•¨ê»˜`ë¸”ë¡`ìœ¼ë¡œ ë„¤íŠ¸ì›Œí¬ì— ë°°í¬í•˜ê²Œ ë¨
        4. í•œ ë…¸ë“œê°€ ì–´ë–¤ **PoW**ë¥¼ í’€ë©´, ë‹¤ë¥¸ ë…¸ë“œë“¤ì€ ê·¸**PoW**ë¥¼ í’€ë ¤ëŠ” ì‹œë„ë¥¼ ë©ˆì¶”ê³  í•´ë‹¹ ë…¸ë“œê°€ ë‚¸ íŠ¸ëœì­ì…˜ ëª©ë¡ì´ ìœ íš¨í•œ ê²ƒì¸ì§€ ê²€ì¦
        5. ìœ íš¨í•˜ë‹¤ë©´ í•´ë‹¹ ë¸”ë¡ì„ ë°›ì•„ë“¤ì´ê³  ë‹¤ìŒ ë¸”ë¡ì„ í’€ê¸° ì‹œì‘
        
        <aside>
        ğŸ“ íŠ¸ëœì­ì…˜ì´ ë…¸ë“œì—ê²Œ ì‹¤í–‰ ì‹ í˜¸ â†’ ë…¸ë“œë“¤ì´ íŠ¸ëœì­ì…˜ì„ ëª¨ì•„ íŠ¸ëœì­ì…˜ ê·¸ë£¹ ë§Œë“¬ â†’ ë…¸ë“œë“¤ì´ íŠ¸ëœì­ì…˜ ì‘ì—…ì¦ëª…(PoW)ë¬¸ì œ í’ˆ â†’ ë„¤íŠ¸ì›Œí¬ì— íŠ¸ëœì­ì…˜ ê·¸ë£¹ì„ PoWì™€ í•¨ê»˜ ë¸”ë¡ìœ¼ë¡œ ë°°í¬ â†’ í•œë…¸ë“œê°€ íŠ¸ë™ì­ì…˜ê·¸ë£¹ì˜ PoWí’€ë©´, ë‹¤ë¥¸ë…¸ë“œ PoW ì‹¤í–‰ ë©ˆì¶¤â†’ íŠ¸ëœì­ì…˜ ëª©ë¡ ìœ íš¨í•œì§€ ê²€ì¦ â†’ ë‹¤ìŒ ë¸”ë¡ í•´ê²°
        
        </aside>
        
        - ì´ê²ƒì´ ìœ„ ë‚œìˆ˜ í•¨ìˆ˜ë¥¼ ì·¨ì•½í•˜ê²Œ ë§Œë“¬
        - ex) ë™ì „ ë˜ì§€ê¸° ì»¨íŠ¸ë™íŠ¸ë¥¼ ì‚¬ìš© - ì•ë©´ ëˆ 2ë°°, ë’·ë©´ ì „ë¶€ ì½ìŒ, ì•ê·€ë©´ ê²°ì •ì„ ìœ„ ë‚œìˆ˜ í•¨ìˆ˜ ì‚¬ìš© (`random >= 50`ì€ ì•ë©´,Â `random < 50`ì€ ë’·ë©´)
        - ë§Œì•½ ë…¸ë“œ ì‹¤í–‰í•œë‹¤ë©´, ì˜¤ì§ ë‚˜ì˜ ë…¸ë“œì—ë§Œ íŠ¸ëœì­ì…˜ì„ ì•Œë¦¬ê³  ê³µìœ  ì•ˆí•  ìˆ˜ ìˆìŒ. ê·¸í›„ ì´ê¸°ëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•´ ë™ì „ ë˜ì§€ê¸° í•¨ìˆ˜ ì‹¤í–‰. - ë§Œì•½ ì§„ë‹¤ë©´ í’€ê³ ìˆëŠ” ë‹¤ìŒ ë¸”ë¡ì— í•´ë‹¹ íŠ¸ëœì­ì…˜ì„ í¬í•¨í•˜ì§€ ì•ŠëŠ” ê²ƒì„ ì„ íƒ, ê²°êµ­ ë™ì „ ë˜ì§€ê¸°ì—ì„œ ì´ê¸°ê³  ë‹¤ìŒ ë¸”ë¡ì„ í’€ ë•Œê¹Œì§€ ë¬´í•œëŒ€ë¡œ ë°˜ë³µí•  ìˆ˜ ìˆìŒ
- ì´ë”ë¦¬ì›€ì—ì„œ ì•ˆì „í•˜ê²Œ ë‚œìˆ˜ ë§Œë“¤ê¸°
    - ì´ë”ë¦¬ì›€ ë¸”ë¡ì²´ì¸ ì™¸ë¶€ì˜ ë‚œìˆ˜ í•¨ìˆ˜ì— ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ ì˜¤ë¼í´ ì‚¬ìš©
    - ê°„ë‹¨í•œ ë‚œìˆ˜ ìƒì„±ê¸°ë¡œ ì‚¬ìš© ì´ìœ 
        - ë„¤íŠ¸ì›Œí¬ ìƒì˜ ìˆ˜ë§Œê°œì˜ ì´ë”ë¦¬ì›€ ë…¸ë“œë“¤ì´ ë‹¤ìŒ ë¸”ë¡ì„ í’€ê¸° ìœ„í•´ ê²½ìŸí•˜ê³  ìˆìœ¼ë‹ˆ, ë‚´ê°€ ë‹¤ìŒ ë¸”ë¡ì„ í’€ í™•ë¥ ì€ ë§¤ìš° ë‚®ìŒ. ìœ„ì—ì„œ ë§í•œ ë¶€ë‹¹í•œ ë°©ë²•ì„ ì“°ëŠ” ê²ƒì€ ë§ì€ ì‹œê°„ê³¼ ì—°ì‚°ìì›ì„ í•„ìš”ë¡œ í•¨ - í•˜ì§€ë§Œ ë³´ìƒì´ ì¶©ë¶„íˆ í¬ë‹¤ë©´, ê³µê²©í•  ë§Œí•œ ê°€ì¹˜ê°€ ìˆì„ ê²ƒ.
        - ì´ëŸ° ë‚œìˆ˜ ìƒì„±ì€ ì´ë”ë¦¬ì›€ ìƒì—ì„œ ì•ˆì „í•˜ì§€ ì•Šì§€ë§Œ, ì‹¤ì œë¡œëŠ” ë‚œìˆ˜ í•¨ìˆ˜ê°€ ì¦‰ì‹œ í° ëˆì´ ë˜ì§€ ì•ŠëŠ” í•œ, ê²Œì„ì˜ ì‚¬ìš©ìë“¤ì€ ê²Œì„ì„ ê³µê²©í•  ë§Œí•œ ì¶©ë¶„í•œ ìì›ì„ ë“¤ì´ì§€ ì•™ã„¶ìŒ
        - ì´ê²Œì„ì€ ëˆì´ ë˜ëŠ” ê²Œ ì—†ê¸° ë•Œë¬¸ì— ê°„ë‹¨í•œ ë‚œìˆ˜ ìƒì„±ê¸°ë¡œ íƒ€í˜‘
        
- ì˜ˆì œ) ê³µê²©ì—ì„œ ì™„ì „íˆ ì•ˆì „í•˜ì§€ëŠ” ì•Šë”ë¼ë„, ì „íˆ¬ì˜ ê²°ê³¼ë¥¼ ê²°ì •í•˜ëŠ” ë°ì— ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë‚œìˆ˜ í•¨ìˆ˜ë¥¼ êµ¬í˜„.
    1. ì»¨íŠ¸ë™íŠ¸ì—Â `randNonce`ë¼ëŠ” ì´ë¦„ì˜Â `uint`Â íƒ€ì… ë³€ìˆ˜ë¥¼ ì¶”ê°€í•˜ê³ ,Â `0`ì„ ëŒ€ì…í•˜ê²Œ.
    2. `randMod`(random-modulus)ë¼ëŠ” ì´ë¦„ì˜ í•¨ìˆ˜ë¥¼ ìƒì„±í•˜ê²Œ. ì´ í•¨ìˆ˜ëŠ”Â `_modulus`ë¼ëŠ” ì´ë¦„ì˜Â `uint`Â íƒ€ì… ë³€ìˆ˜ë¥¼ ë°›ëŠ”Â `internal`Â í•¨ìˆ˜ì¼ ê²ƒì´ê³ ,Â `uint`Â íƒ€ì…ì„ ë°˜í™˜(`returns`)í•  ê²ƒì´ë„¤.
    3. í•´ë‹¹ í•¨ìˆ˜ëŠ” ë¨¼ì €Â `randNonce`ë¥¼ í•˜ë‚˜ ì¦ê°€ì‹œí‚¬ ê²ƒì´ë„¤(`randNonce++`Â ë¬¸ë²•ì„ ì‚¬ìš©í•˜ê²Œ).
    4. ë§ˆì§€ë§‰ìœ¼ë¡œ, (í•œ ì¤„ì˜ ì½”ë“œë¡œ)`now`,Â `msg.sender`,Â `randNonce`ì˜Â `keccak256`Â í•´ì‹œ ê°’ì„ ê³„ì‚°í•˜ê³ Â `uint`ë¡œ ë³€í™˜í•´ì•¼ í•˜ë„¤ - ê·¸ë¦¬ê³  ê·¸ ê°’Â `% _modulus`ë¥¼ í•œ í›„Â `return`í•´ì•¼ í•˜ë„¤(í›„, ë‚´ìš©ì´ ì•„ì£¼ ì¥í™©í—€êµ°. ì˜ ì´í•´ê°€ ì•ˆ ëœë‹¤ë©´, ìœ„ì—ì„œ ìš°ë¦¬ê°€ ë‚œìˆ˜ë¥¼ ë§Œë“¤ì—ˆë˜ ì˜ˆì‹œë¥¼ ë³´ê²Œ - êµ¬ì¡°ê°€ ë§¤ìš° ìœ ì‚¬í•˜ë„¤).
    - ì˜ˆì œ ì½”ë“œ)
        
        ```solidity
        import "./zombiehelper.sol";
        
        contract ZombieBattle is ZombieHelper {
          uint randNonce = 0;
          function randMod(uint _modulus) internal returns(uint) {
            randNonce++;
            return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
          }
        }
        ```
        

### ì¢€ë¹„ì‹¸ì›€

- ì¢€ë¹„ ì „íˆ¬ ì§„í–‰
    - ìë„¤ê°€ ìë„¤ ì¢€ë¹„ ì¤‘ í•˜ë‚˜ë¥¼ ê³ ë¥´ê³ , ìƒëŒ€ë°©ì˜ ì¢€ë¹„ë¥¼ ê³µê²© ëŒ€ìƒìœ¼ë¡œ ì„ íƒí•˜ë„¤.
    - ìë„¤ê°€ ê³µê²©í•˜ëŠ” ìª½ì˜ ì¢€ë¹„ë¼ë©´, ìë„¤ëŠ” 70%ì˜ ìŠ¹ë¦¬ í™•ë¥ ì„ ê°€ì§€ë„¤. ë°©ì–´í•˜ëŠ” ìª½ì˜ ì¢€ë¹„ëŠ” 30%ì˜ ìŠ¹ë¦¬ í™•ë¥ ì„ ê°€ì§ˆ ê²ƒì´ë„¤.
    - ëª¨ë“  ì¢€ë¹„ë“¤(ê³µê²©, ë°©ì–´ ëª¨ë‘)ì€ ì „íˆ¬ ê²°ê³¼ì— ë”°ë¼ ì¦ê°€í•˜ëŠ”Â `winCount`ì™€Â `lossCount`ë¥¼ ê°€ì§ˆ ê²ƒì´ë„¤.
    - ê³µê²©í•˜ëŠ” ìª½ì˜ ì¢€ë¹„ê°€ ì´ê¸°ë©´, ì¢€ë¹„ì˜ ë ˆë²¨ì´ ì˜¤ë¥´ê³  ìƒˆë¡œìš´ ì¢€ë¹„ê°€ ìƒê¸°ë„¤.
    - ì¢€ë¹„ê°€ ì§€ë©´, ì•„ë¬´ê²ƒë„ ì¼ì–´ë‚˜ì§€ ì•Šë„¤(ì¢€ë¹„ì˜Â `lossCount`ê°€ ì¦ê°€í•˜ëŠ” ê²ƒ ë¹¼ê³  ë§ì´ì•¼).
    - ì¢€ë¹„ê°€ ì´ê¸°ë“  ì§€ë“ , ê³µê²©í•˜ëŠ” ìª½ ì¢€ë¹„ì˜ ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ì´ í™œì„±í™”ë  ê²ƒì´ë„¤.
- ì˜ˆì œ)
    1. ì»¨íŠ¸ë™íŠ¸ì—Â `attackVictoryProbability`ë¼ëŠ” ì´ë¦„ì˜Â `uint`Â ë³€ìˆ˜ë¥¼ ì¶”ê°€í•˜ê³ , ì—¬ê¸°ì—Â `70`ì„ ëŒ€ì…í•˜ê²Œ.
    2. `attack`ì´ë¼ëŠ” ì´ë¦„ì˜ í•¨ìˆ˜ë¥¼ ìƒì„±í•˜ê²Œ. ì´ í•¨ìˆ˜ëŠ” ë‘ ê°œì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ë°›ì„ ê²ƒì´ë„¤:Â `_zombieId`(`uint`)ì™€Â `_targetId`(`uint`)ì´ë„¤. ì´ í•¨ìˆ˜ëŠ”Â `external`ì´ì–´ì•¼ í•˜ë„¤.
    - ì˜ˆì œ ì½”ë“œ
        
        ```solidity
        import "./zombiehelper.sol";
        
        contract ZombieBattle is ZombieHelper {
          uint randNonce = 0;
          // ì—¬ê¸°ì— attackVictoryProbabilityë¥¼ ë§Œë“¤ê²Œ
          uint attackVictoryProbability = 70;
        
          function randMod(uint _modulus) internal returns(uint) {
            randNonce++;
            return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
          }
        
          // ì—¬ê¸°ì— ìƒˆë¡œìš´ í•¨ìˆ˜ë¥¼ ë§Œë“¤ê²Œ
          function attack(uint _zombieId, uint _targetId) external {
        
          }
        }
        ```
        

### ê³µí†µ ë¡œì§ êµ¬ì¡° ê°œì„ í•˜ê¸°

- ì‚¬ìš©ìê°€ ê³µê²©ì— ì‚¬ìš©í•˜ëŠ” ì¢€ë¹„ë¥¼ ì‹¤ì œë¡œ ì†Œìœ í•˜ê³  ìˆë‹¤ëŠ” ê²ƒì„ í™•ì‹¤íˆ í•˜ê³  ì‹¶ìŒ. ë§Œì•½ ë‹¤ë¥¸ ì‚¬ëŒì˜ ì¢€ë¹„ë¥¼ ì‚¬ìš©í•´ì„œ ê³µê²©í•  ìˆ˜ ìˆë‹¤ë©´ ë³´ì•ˆì— ë¬¸ì œê°€ ë˜ëŠ” ë¶€ë¶„.
- í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ì‚¬ëŒì´ ê·¸ê°€ ì‚¬ìš©í•œÂ `_zombieId`ì˜ ì†Œìœ ìì¸ì§€ í™•ì¸í•  ë°©ë²•
    
    ```solidity
    require(msg.sender == zombieToOwner[_zombieId]);
    ```
    
    - ë™ì¼í•œ ë‚´ìš©ì„ ì—¬ëŸ¬ ë²ˆ ì‚¬ìš©í•˜ê³  ìˆìœ¼ë‹ˆ, ì½”ë“œë¥¼ ì •ë¦¬í•˜ê³  ë°˜ë³µì„ í”¼í•  ìˆ˜ ìˆë„ë¡ ì´ ë‚´ìš©ì„ ì´ê²ƒë§Œì˜Â `modifier`ë¡œ ì˜®ê¹€
- ì˜ˆì œ) `zombiefeeding.sol`ì„ ë‹¤ì‹œ í•´ë´„. í™•ì¸ ë¶€ë¶„ì„ ê·¸ ë¶€ë¶„ë§Œì˜Â `modifier`ë¡œ ë§Œë“¤ì–´ êµ¬ì¡°ë¥¼ ê°œì„ 
    1. `modifier`ë¥¼Â `ownerOf`ë¼ëŠ” ì´ë¦„ìœ¼ë¡œ ë§Œë“¤ê²Œ. ì´ ì œì–´ìëŠ”Â `_zombieId`(`uint`)ë¥¼ 1ê°œì˜ ì¸ìˆ˜ë¡œ ë°›ì„ ê²ƒì´ë„¤.
        
        ì œì–´ì ë‚´ìš©ì—ì„œëŠ”Â `msg.sender`ì™€Â `zombieToOwner[_zombieId]`ê°€ ê°™ì€ì§€Â `require`ë¡œ í™•ì¸í•˜ê³ , í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•´ì•¼ í•˜ë„¤. ì œì–´ìì˜ ë¬¸ë²•ì´ ê¸°ì–µì´ ë‚˜ì§€ ì•ŠëŠ”ë‹¤ë©´Â `zombiehelper.sol`ì„ ì°¸ê³ í•˜ë©´ ë˜ë„¤.
        
    2. `feedAndMultiply`ì˜ í•¨ìˆ˜ ì •ì˜ ë¶€ë¶„ì„Â `ownerOf`Â ì œì–´ìë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë°”ê¾¸ê²Œ.
    3. ì´ì œÂ `modifier`ë¥¼ ì‚¬ìš©í•˜ê²Œ ëìœ¼ë‹ˆ,Â `require(msg.sender == zombieToOwner[_zombieId]);`Â ì¤„ì„ ì§€ì›Œë„ ë˜ë„¤.
    - ì˜ˆì œ ì½”ë“œ
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefactory.sol";
        
        contract KittyInterface {
          function getKitty(uint256 _id) external view returns (
            bool isGestating,
            bool isReady,
            uint256 cooldownIndex,
            uint256 nextActionAt,
            uint256 siringWithId,
            uint256 birthTime,
            uint256 matronId,
            uint256 sireId,
            uint256 generation,
            uint256 genes
          );
        }
        
        contract ZombieFeeding is ZombieFactory {
        
          KittyInterface kittyContract;
        
          // 1. ì—¬ê¸°ì— ì œì–´ìë¥¼ ìƒì„±í•˜ê²Œ
          modifier ownerOf(uint _zombieId){
            require(msg.sender == zombieToOwner[_zombieId]);
            _;
          }
        
          function setKittyContractAddress(address _address) external onlyOwner {
            kittyContract = KittyInterface(_address);
          }
        
          function _triggerCooldown(Zombie storage _zombie) internal {
            _zombie.readyTime = uint32(now + cooldownTime);
          }
        
          function _isReady(Zombie storage _zombie) internal view returns (bool) {
              return (_zombie.readyTime <= now);
          }
        
          // 2. í•¨ìˆ˜ ì •ì˜ ë¶€ë¶„ì— ì œì–´ìë¥¼ ì¶”ê°€í•˜ê²Œ:
          function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal ownerOf(_zombieId) {
            // 3. ì´ ì¤„ì„ ì§€ìš°ê²Œ
            Zombie storage myZombie = zombies[_zombieId];
            require(_isReady(myZombie));
            _targetDna = _targetDna % dnaModulus;
            uint newDna = (myZombie.dna + _targetDna) / 2;
            if (keccak256(_species) == keccak256("kitty")) {
              newDna = newDna - newDna % 100 + 99;
            }
            _createZombie("NoName", newDna);
            _triggerCooldown(myZombie);
          }
        
          function feedOnKitty(uint _zombieId, uint _kittyId) public {
            uint kittyDna;
            (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
            feedAndMultiply(_zombieId, kittyDna, "kitty");
          }
        }
        ```
        
- êµ¬ì¡° ë” ê°œì„ í•˜ê¸°
    1. `changeName()`ë¥¼Â `ownerOf`ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½í•˜ê²Œ.
    2. `changeDna()`ë¥¼Â `ownerOf`ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½í•˜ê²Œ.
    - ì˜ˆì œ ì½”ë“œ
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./zombiefeeding.sol";
        
        contract ZombieHelper is ZombieFeeding {
        
          uint levelUpFee = 0.001 ether;
        
          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }
        
          function withdraw() external onlyOwner {
            owner.transfer(this.balance);
          }
        
          function setLevelUpFee(uint _fee) external onlyOwner {
            levelUpFee = _fee;
          }
        
          // 1. ì´ í•¨ìˆ˜ë¥¼ `ownerOf`ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½í•˜ê²Œ:
          function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) ownerOf(_zombieId) {
            zombies[_zombieId].name = _newName;
          }
        
          // 2. ì´ í•¨ìˆ˜ì—ë„ ë˜‘ê°™ì´ ì ìš©í•˜ê²Œ:
          function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) ownerOf(_zombieId) {
            zombies[_zombieId].dna = _newDna;
          }
        
          function getZombiesByOwner(address _owner) external view returns(uint[]) {
            uint[] memory result = new uint[](ownerZombieCount[_owner]);
            uint counter = 0;
            for (uint i = 0; i < zombies.length; i++) {
              if (zombieToOwner[i] == _owner) {
                result[counter] = i;
                counter++;
              }
            }
            return result;
          }
        
        }
        ```
        

### ê³µê²©ìœ¼ë¡œ ëŒì•„ê°€ì

- `attack`í•¨ìˆ˜ë¥¼ ê³„ì† ì •ì˜
- ì˜ˆì œ)
    1. í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ì‚¬ëŒì´Â `_zombieId`ë¥¼ ì†Œìœ í•˜ê³  ìˆëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•´Â `attack`Â í•¨ìˆ˜ì—Â `ownerOf`Â ì œì–´ìë¥¼ ì¶”ê°€í•˜ê²Œ.
    2. ìš°ë¦¬ í•¨ìˆ˜ì—ì„œ ì²˜ìŒìœ¼ë¡œ í•´ì•¼ í•  ê²ƒì€ ë‘ ì¢€ë¹„ì˜Â `storage`Â í¬ì¸í„°ë¥¼ ì–»ì–´ì„œ ê·¸ë“¤ê³¼ ìƒí˜¸ì‘ìš© í•˜ê¸° ì‰½ë„ë¡ í•˜ëŠ” ê²ƒì´ë„¤.
        
        a.Â `Zombie storage`ë¥¼Â `myZombie`ë¼ëŠ” ì´ë¦„ìœ¼ë¡œ ì„ ì–¸í•˜ê³ , ì—¬ê¸°ì—Â `zombies[_zombieId]`ë¥¼ ëŒ€ì…í•˜ê²Œ.
        
        b.Â `Zombie storage`ë¥¼Â `enemyZombie`ë¼ëŠ” ì´ë¦„ìœ¼ë¡œ ì„ ì–¸í•˜ê³ , ì—¬ê¸°ì—Â `zombies[_targetId]`ë¥¼ ëŒ€ì…í•˜ê²Œ.
        
    3. ìš°ë¦° ì „íˆ¬ì˜ ê²°ê³¼ë¥¼ ê²°ì •í•˜ê¸° ìœ„í•´ 0ê³¼ 99 ì‚¬ì´ì˜ ë‚œìˆ˜ë¥¼ ì‚¬ìš©í•  ê²ƒì´ë„¤. ê·¸ëŸ¬ë‹ˆÂ `uint`ë¥¼Â `rand`ë¼ëŠ” ì´ë¦„ìœ¼ë¡œ ì„ ì–¸í•˜ê³ , ì—¬ê¸°ì—Â `randMod`Â í•¨ìˆ˜ì—Â `100`ì„ ì¸ìˆ˜ë¡œ ì‚¬ìš©í•œ ê°’ì„ ëŒ€ì…í•˜ê²Œ.
    - ì˜ˆì œ ì½”ë“œ
        
        ```solidity
        import "./zombiehelper.sol";
        
        contract ZombieBattle is ZombieHelper {
          uint randNonce = 0;
          uint attackVictoryProbability = 70;
        
          function randMod(uint _modulus) internal returns(uint) {
            randNonce++;
            return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
          }
        
          // 1. ì—¬ê¸°ì— ì œì–´ìë¥¼ ì¶”ê°€í•˜ê²Œ
          function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {
            // 2. ì—¬ê¸°ì„œ í•¨ìˆ˜ ì •ì˜ë¥¼ ì‹œì‘í•˜ê²Œ
            Zombie storage myZombie = zombies[_zombieId];
            Zombie storage enemyZombie = zombies[_targetId];
            uint rand = randMod(100);
          }
        }
        ```
        

### ì¢€ë¹„ ìŠ¹ë¦¬ì™€ íŒ¨ë°°

- ì¢€ë¹„ë“¤ì´ ì–¼ë§ˆë‚˜ ë§ì´ ì´ê¸°ê³  ì¡ŒëŠ”ì§€ë¥¼ ì¶”ì . ì´ë ‡ê²Œ í•˜ë©´ ê²Œì„ ìƒì—ì„œ "ì¢€ë¹„ ìˆœìœ„í‘œ"ë¥¼ ìœ ì§€
    - DAppì—ì„œ ë‹¤ì–‘í•œ ë°©ì‹ìœ¼ë¡œ ì´ ë°ì´í„°ë¥¼ ì €ì¥í•  ìˆ˜ ìˆìŒ - ê°œë³„ì ì¸ ë§¤í•‘ìœ¼ë¡œ, ìˆœìœ„í‘œ êµ¬ì¡°ì²´ë¡œ, í˜¹ì€Â `Zombie`Â êµ¬ì¡°ì²´ ìì²´ì— ë„£ì„ ìˆ˜ë„ ìˆìŒ
    - `Zombie`Â êµ¬ì¡°ì²´ì— ìƒíƒœë¥¼ ì €ì¥í•˜ë„ë¡ í•˜ê³ , ì´ë“¤ì„Â `winCount`ì™€Â `lossCount`ë¡œ ì´ë¦„ì§“ë„ë¡ í•¨.
- ì˜ˆì œ)
    1. `Zombie`Â êµ¬ì¡°ì²´ê°€ 2ê°œì˜ ì†ì„±ì„ ë” ê°€ì§€ë„ë¡ ìˆ˜ì •í•˜ê²Œ:
        
        a.Â `winCount`,Â `uint16`Â íƒ€ì…
        
        b.Â `lossCount`, ì—­ì‹œÂ `uint16`Â íƒ€ì…
        
        > ì°¸ê³ : ê¸°ì–µí•˜ê²Œ, êµ¬ì¡°ì²´ ì•ˆì—ì„œÂ uintë“¤ì„ ì••ì¶•(pack)í•  ìˆ˜ ìˆìœ¼ë‹ˆ, ìš°ë¦¬ê°€ ë‹¤ë£° ìˆ˜ ìˆëŠ” ê°€ì¥ ì‘ì€Â uintÂ íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ì„ ê²ƒì´ë„¤.Â uint8ì€ ë„ˆë¬´ ì‘ì„ ê²ƒì´ë„¤. 2^8 = 256ì´ê¸° ë•Œë¬¸ì´ì§€ - ë§Œì•½ ìš°ë¦¬ ì¢€ë¹„ê°€ í•˜ë£¨ì— í•œ ë²ˆì”© ê³µê²©í•œë‹¤ë©´, ì¼ ë…„ ì•ˆì— ë°ì´í„° í¬ê¸°ê°€ ë„˜ì³ë²„ë¦´ ìˆ˜ ìˆì„ ê²ƒì´ë„¤. í•˜ì§€ë§Œ 2^16ì€ 65536ì´ë„¤ - ê·¸ëŸ¬ë‹ˆ í•œ ì‚¬ìš©ìê°€ ë§¤ì¼ 179ë…„ ë™ì•ˆ ì´ê¸°ê±°ë‚˜ ì§€ì§€ ì•ŠëŠ”ë‹¤ë©´, ì´ê±¸ë¡œ ì•ˆì „í•  ê²ƒì´ë„¤.
        > 
    2. ì´ì œ ìš°ë¦¬ëŠ”Â `Zombie`Â êµ¬ì¡°ì²´ì— ìƒˆë¡œìš´ ì†ì„±ë“¤ì„ ê°€ì§€ê²Œ ë˜ì—ˆìœ¼ë‹ˆ,Â `_createZombie()`ì˜ í•¨ìˆ˜ ì •ì˜ ë¶€ë¶„ì„ ìˆ˜ì •í•´ì•¼ í•  í•„ìš”ê°€ ìˆë„¤.
        
        ê°ê°ì˜ ìƒˆë¡œìš´ ì¢€ë¹„ê°€Â `0`ìŠ¹Â `0`íŒ¨ë¥¼ ê°€ì§€ê³  ìƒì„±ë  ìˆ˜ ìˆë„ë¡ ì¢€ë¹„ ìƒì„±ì˜ ì •ì˜ ë¶€ë¶„ì„ ë³€ê²½í•˜ê²Œ.
        
    - ì˜ˆì œ ì½”ë“œ
        
        ```solidity
        pragma solidity ^0.4.19;
        
        import "./ownable.sol";
        
        contract ZombieFactory is Ownable {
        
            event NewZombie(uint zombieId, string name, uint dna);
        
            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;
            uint cooldownTime = 1 days;
        
            struct Zombie {
              string name;
              uint dna;
              uint32 level;
              uint32 readyTime;
              // 1. ì—¬ê¸°ì— ìƒˆë¡œìš´ ì†ì„±ì„ ì¶”ê°€í•˜ê²Œ
              uint16 winCount;
              uint16 lossCount;
            }
        
            Zombie[] public zombies;
        
            mapping (uint => address) public zombieToOwner;
            mapping (address => uint) ownerZombieCount;
        
            function _createZombie(string _name, uint _dna) internal {
                // 2. ì—¬ê¸°ì„œ ìƒˆë¡œìš´ ì¢€ë¹„ì˜ ìƒì„±ì„ ìˆ˜ì •í•˜ê²Œ:
                uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;
                zombieToOwner[id] = msg.sender;
                ownerZombieCount[msg.sender]++;
                NewZombie(id, _name, _dna);
            }
        
            function _generateRandomDna(string _str) private view returns (uint) {
                uint rand = uint(keccak256(_str));
                return rand % dnaModulus;
            }
        
            function createRandomZombie(string _name) public {
                require(ownerZombieCount[msg.sender] == 0);
                uint randDna = _generateRandomDna(_name);
                randDna = randDna - randDna % 100;
                _createZombie(_name, randDna);
            }
        
        }
        ```
        

### ì¢€ë¹„ ìŠ¹ë¦¬

- 0ë¶€í„° 100ê¹Œì§€ì˜ ë‚œìˆ˜ë¥¼ ê³„ì‚°. ê·¸ ìˆ«ìë¥¼ ëˆ„ê°€ ì‹¸ì›€ì—ì„œ ì´ê¸¸ì§€ ê²°ì •í•˜ëŠ” ë°ì— ì‚¬ìš©í•˜ê³ , ê·¸ì— ë”°ë¼ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸
- ì˜ˆì œ)
    1. `rand`ê°€Â `attackVictoryProbability`ì™€Â ***ê°™ê±°ë‚˜ ë” ì‘ì€ì§€***Â í™•ì¸í•˜ëŠ”Â `if`Â ë¬¸ì¥ì„ ë§Œë“¤ê²Œ.
    2. ë§Œì•½ ì´ ì¡°ê±´ì´ ì°¸ì´ë¼ë©´, ìš°ë¦¬ ì¢€ë¹„ê°€ ì´ê¸°ê²Œ ë˜ë„¤! ê·¸ë ‡ë‹¤ë©´:
        
        a.Â `myZombie`ì˜Â `winCount`ë¥¼ ì¦ê°€ì‹œí‚¤ê²Œ.
        
        b.Â `myZombie`ì˜Â `level`ì„ ì¦ê°€ì‹œí‚¤ê²Œ. (ë ˆë²¨ì—…ì´ë‹¤!!!!!!!)
        
        c.Â `enemyZombie`ì˜Â `lossCount`ë¥¼ ì¦ê°€ì‹œí‚¤ê²Œ. (ì´ íŒ¨ë°°ì!!!!!!! ğŸ˜« ğŸ˜« ğŸ˜«)
        
        d.Â `feedAndMultiply`Â í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê²Œ. ì‹¤í–‰ì„ ìœ„í•œ ë¬¸ë²•ì„ ë³´ë ¤ë©´Â `zombiefeeding.sol`ì„ í™•ì¸í•˜ê²Œ. 3ë²ˆì§¸ ì¸ìˆ˜(`_species`)ë¡œëŠ”Â `"zombie"`ë¼ëŠ” ë¬¸ìì—´ì„ ì „ë‹¬í•˜ê²Œ(ì´ê±´ ì§€ê¸ˆ ì´ ìˆœê°„ì—ëŠ” ì‹¤ì œë¡œ ì•„ë¬´ ê²ƒë„ í•˜ì§€ ì•Šì§€ë§Œ, ì´í›„ì— ìš°ë¦¬ê°€ ì›í•œë‹¤ë©´ ì¢€ë¹„ ê¸°ë°˜ì˜ ì¢€ë¹„ë¥¼ ë§Œë“¤ì–´ë‚´ëŠ” ë¶€ê°€ì ì¸ ê¸°ëŠ¥ì„ ì¶”ê°€í•  ìˆ˜ë„ ìˆì„ ê²ƒì´ë„¤).
        
        - ì˜ˆì œ ì½”ë“œ
            
            ```solidity
            import "./zombiehelper.sol";
            
            contract ZombieBattle is ZombieHelper {
              uint randNonce = 0;
              uint attackVictoryProbability = 70;
            
              function randMod(uint _modulus) internal returns(uint) {
                randNonce++;
                return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
              }
            
              function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {
                Zombie storage myZombie = zombies[_zombieId];
                Zombie storage enemyZombie = zombies[_targetId];
                uint rand = randMod(100);
                // ì—¬ê¸°ì„œ ì‹œì‘í•˜ê²Œ
                if (rand <= attackVictoryProbability) {
                  myZombie.winCount++;
                  myZombie.level++;
                  enemyZombie.lossCount++;
                  feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");
                }
              }
            }
            ```
            

### ì¢€ë¹„ íŒ¨ë°°

- ì¢€ë¹„ì˜Â `lossCount`ì— ê·¸ë“¤ì˜ íŒ¨ë°°ë¥¼ ê¸°ë¡í•˜ê³ , ë‹¤ì‹œ ê³µê²©í•˜ê¸° ì „ì— í•˜ë£¨ë¥¼ ê¸°ë‹¤ë ¤ì•¼ë§Œ í•˜ë„ë¡ ê·¸ë“¤ì˜ ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ì´ í™œì„±í™” í•¨.
- ì˜ˆì œ)
    1. `else`Â ë¬¸ì¥ì„ ì¶”ê°€í•˜ê²Œ. ë§Œì•½ ìš°ë¦¬ì˜ ì¢€ë¹„ê°€ ì§„ë‹¤ë©´:
        
        a.Â `myZombie`ì˜Â `lossCount`ë¥¼ ì¦ê°€ì‹œí‚¤ê²Œ.
        
        b.Â `enemyZombie`ì˜Â `winCount`ë¥¼ ì¦ê°€ì‹œí‚¤ê²Œ.
        
    2. else ë¬¸ì¥ì˜ ë°–ì—ì„œ,Â `myZombie`ì— ëŒ€í•´Â `_triggerCooldown`Â í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê²Œ. ì´ëŸ¬í•œ ë°©ë²•ìœ¼ë¡œ í•´ë‹¹ ì¢€ë¹„ëŠ” í•˜ë£¨ì— í•œ ë²ˆë§Œ ê³µê²©í•  ìˆ˜ ìˆë„¤.
    - ì˜ˆì œ ì½”ë“œ
        
        ```solidity
        import "./zombiehelper.sol";
        
        contract ZombieBattle is ZombieHelper {
          uint randNonce = 0;
          uint attackVictoryProbability = 70;
        
          function randMod(uint _modulus) internal returns(uint) {
            randNonce++;
            return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
          }
        
          function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {
            Zombie storage myZombie = zombies[_zombieId];
            Zombie storage enemyZombie = zombies[_targetId];
            uint rand = randMod(100);
            if (rand <= attackVictoryProbability) {
              myZombie.winCount++;
              myZombie.level++;
              enemyZombie.lossCount++;
              feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");
            } // ì—¬ê¸°ì„œ ì‹œì‘í•˜ê²Œ
            else{
              myZombie.lossCount++;
              enemyZombie.winCount++;
            }
            _triggerCooldown(myZombie);
          }
        }
        ```